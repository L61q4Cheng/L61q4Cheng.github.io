<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Dalvik指令集</title>
    <url>/2021/07/22/Dalvik%E6%8C%87%E4%BB%A4%E9%9B%86/</url>
    <content><![CDATA[<p>Dalvik是Google公司自己设计的用于Android平台的虚拟机。Dalvik虚拟机是Google等厂商合作开发的Android移动设备平台的核心组成部分之一。它可以支持已转换为 .dex（即Dalvik Executable）格式的Java应用程序的运行，.dex格式是专为Dalvik设计的一种压缩格式，适合内存和处理器速度有限的系统。<span id="more"></span>Dalvik 经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik 应用作为一个独立的Linux 进程执行。独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。一段Dalvik汇编代码由一系列Dalvik指令组成，指令语法由指令的位描述与指令格式标识来决定。</p>
<p>Dalvik虚拟机是基于寄存器架构的，数据的访问通过寄存器单间直接传递。对java的每个线程都有一个pc计数器和一个java栈。Pc计数器类似arm cpu中的PC寄存器和x86 cpu中的IP寄存器，不同的是，PC计数器只对当前方法有效。</p>
<table>
<thead>
<tr>
<th>语    法</th>
<th>含      义</th>
</tr>
</thead>
<tbody><tr>
<td>V</td>
<td>void,只用于返回值类型</td>
</tr>
<tr>
<td>Z</td>
<td>boolean</td>
</tr>
<tr>
<td>B</td>
<td>byte</td>
</tr>
<tr>
<td>S</td>
<td>short</td>
</tr>
<tr>
<td>C</td>
<td>char</td>
</tr>
<tr>
<td>I</td>
<td>int</td>
</tr>
<tr>
<td>J</td>
<td>long</td>
</tr>
<tr>
<td>F</td>
<td>float</td>
</tr>
<tr>
<td>D</td>
<td>double</td>
</tr>
<tr>
<td>L</td>
<td>Java类类型</td>
</tr>
<tr>
<td>[</td>
<td>数组类型</td>
</tr>
</tbody></table>
<h3 id="1、空操作指令"><a href="#1、空操作指令" class="headerlink" title="1、空操作指令"></a>1、空操作指令</h3><p>助记符为nop，值为00，通常用来做对齐代码，无实际操作。</p>
<h3 id="2、数据操作指令-move"><a href="#2、数据操作指令-move" class="headerlink" title="2、数据操作指令 move"></a>2、数据操作指令 move</h3><h3 id="3、返回指令-return"><a href="#3、返回指令-return" class="headerlink" title="3、返回指令  return"></a>3、返回指令  return</h3><p>“return-void”表示函数从一个void方法返回。</p>
<p>“return vAA表示函数返回一个32位非对象类型的值,回值寄存器为8位的寄存器vAA</p>
<p>“return-wide vAA表示函数返回一个64位非对象类型的值。返回值为8位的寄存器对vAA</p>
<p>“return object vAA”表示函数返回一个对象类型的值。返回值为8位的寄存器vAA</p>
<h3 id="4、数据定义指令-const"><a href="#4、数据定义指令-const" class="headerlink" title="4、数据定义指令 const"></a>4、数据定义指令 const</h3><p>用来定义程序中用到的常量、字符串、类等数据。</p>
<p>“const/high16   vAA,#+B000”将数值右边零扩展为32位后赋给寄存器vAA。</p>
<p>“const-wide/16  vAA,#+BBBB”将数值符号扩展为64位后赋给寄存器对vAA.</p>
<p>“const-wide/32  vAA,#+BBBBBBBB”将数值符号扩展为64位后赋给寄存器对vAA</p>
<p>“const-wide   vAA,#+BBBBBBBBBBBBBBBB”将数值赋给寄存器对vAA</p>
<p>“const–wide/high16  vAA,#+BB00000000将数值右边零扩展为64位后赋给寄存器对vAA</p>
<p>“cost-string vAA, string@BBBBBBBB”通过字符串索引构造一个字符串并赋给寄存器vAA</p>
<p>“const-string-/jumbo vAA, string@BBBBBBBB”通过字符串索引(较大)构造一个字符串并赋给寄存器vAA。</p>
<p>“const-class- vAA,type@BBBB”通过类型索引获取一个类引用并赋给寄存器vAA</p>
<p>“const-class-/jumbo vAAAA,type@BBBBBBBB”通过给定的类型索引获取一个类引用并赋给寄存器 VAAAA.这条指令占用两个字节,值为 OxOOff( Android 4.4.0中新增的指)</p>
<h3 id="5、实例操作指令"><a href="#5、实例操作指令" class="headerlink" title="5、实例操作指令"></a>5、实例操作指令</h3><p>类型转换，检查，新建。</p>
<p>“check-cast vAA,type@BBBB”将vAA寄存器中的对象引用转换成指定的类型,如果失败会抛出 ClassCastException异常。如果类型B指定的是基本类型,对于非基本类型的A来说,运行时始终会失败。</p>
<p>”instance-of vA,vB,type@CCCC”判断vB寄存器中的对象引用是否可以转换成指定的类型,如果可以vA寄存器赋值为1,否则vA寄存器赋值为0。</p>
<p>“new-instance VAA,type@BBBB”构造一个指定类型对象的新实例,并将对象引用赋值给vAA寄存器,类型符tpe指定的类型不能是数组类.</p>
<p>“check-cast/jumbo VAAAA, type@BBBBBBBB”指令功能与“ check-cast vAA,type@BBBB”相同,只是寄存器值与指令的索引取值范围更大( Android4.0中新增的指令)</p>
<p>“ instance-of/jumbo VAAAA, VBBBB,type@ CCCCCCCC”指令功能与“ instance-of vA ,vB ,type @cCCC”相同,只是寄存器值与指令的索引取值范围更大( Android40中新增的指令)。</p>
<p>“new-instance/jumbo VAAA/,type@ BBBBBBBB”指令功能与“new- instance VAA,type@BBBB”相同,只是寄存器值与指令的索引取值范围更大( Android4.0中新增的指令)</p>
<h3 id="6、锁指令-monitor-多用在多线程程序中对同一对象的操作"><a href="#6、锁指令-monitor-多用在多线程程序中对同一对象的操作" class="headerlink" title="6、锁指令  monitor  (多用在多线程程序中对同一对象的操作)"></a>6、锁指令  monitor  (多用在多线程程序中对同一对象的操作)</h3><p>“monitor-enter  vAA”为指定的对象获得锁。</p>
<p>“monitor -exit vAA” 释放指定的对象的锁。</p>
<h3 id="7、数组操作指令"><a href="#7、数组操作指令" class="headerlink" title="7、数组操作指令"></a>7、数组操作指令</h3><p>包括数组长度，新建数组，数组赋值，数组元素取值与赋值等操作。</p>
<p>“array length vA,vB”获取给定vB寄存器中数组的长度并将值赋给vA寄存器，数组长度指的是数组的条目个数。</p>
<p>“new- array vA,vB,type@CCCC”构造指定类型( (type@CCCC)与大小(vB)的数组并将值赋给vA寄存器.</p>
<p>“ filled-new array{ vC,vD,vE,vF},type@BBBB构造指定类型( type@BBBB))与大小(vA)的数组填充数组内容。vA寄存器是隐含使用的，除了指定数组的大小外还指定了参数的个数，vC~vG是使用到的参数寄存器序列。</p>
<p>“filled-new-array/range{vCCCC..vNNNN),type@BBBB指令功能与“ filled-new  array{vC,vD,vE, vfF,vG},type@BBBB”相同，只是参数寄存器使用range字节码后指定了取值范围，vC是第一个参数寄存器，N=A+C-1。</p>
<p>“filled-array-data vAA,+ BBBBBBBB”用指定的数据来填充数组，vAA寄存器为数组引用，引用必须为基础类型的数组，在指令后面会紧跟一个数据表。</p>
<p>“new- -array/jumbo vAAAA, VBBBB,type@CCCCCCCC指令功能与“new- array vA,vB,type @CCCC相同，只是寄存器值与指令的索引取值范围更大( Android4.0中新增的指令)</p>
<p>“filled new-array/jumb{vCCCC..vNNNN),type@BBBBBBBB指令功能与 filled-new-array/range fvCCCC.nn)， type@BBBE”相同，只是索引取值范围更大( Android4.0中新增的指令)。</p>
<p>“ arrayop vAA,vBB,vCC对vBB寄存器指定的数组元素进入取值与赋值。vCC寄存器指定数组元素索引，vAA寄存器用来存放读取的或需要设置的数组元素的值。读取元素使用aget类指令，元素赋值使用aput类指令，根据数组中存储的类型指令后面会紧跟不同的指令后，指令列表有aget aget-wide, aget-object, aget-boolean, aget-byte, aget-char aget-short, aput, aput-wide, aput-object, aput-boolean, aput-byte,aput-char,aput-short.</p>
<h3 id="8、异常指令-抛出异常"><a href="#8、异常指令-抛出异常" class="headerlink" title="8、异常指令  抛出异常"></a>8、异常指令  抛出异常</h3><p>“throw vAA”抛出vAA寄存器中指定类型的异常。</p>
<h3 id="9、跳转指令-当前地址跳转到指定的偏移量。"><a href="#9、跳转指令-当前地址跳转到指定的偏移量。" class="headerlink" title="9、跳转指令   当前地址跳转到指定的偏移量。"></a>9、跳转指令   当前地址跳转到指定的偏移量。</h3><h4 id="1-无条件跳转-goto"><a href="#1-无条件跳转-goto" class="headerlink" title="1)  无条件跳转(goto)"></a>1)  无条件跳转(goto)</h4><p>“goto +AA”无条件跳转到指定偏移处，偏移量AA不能为0.</p>
<p>“goto/16 +AAAA”无条件跳转到指定偏移处，偏移量AAAA不能为0.</p>
<p>“goto/32 +AAAAAAAA”无条件跳转到指定偏移处.</p>
<h4 id="2-分支跳转（switch）"><a href="#2-分支跳转（switch）" class="headerlink" title="2)  分支跳转（switch）"></a>2)  分支跳转（switch）</h4><p>“ packed- switch vAA +BBBBBBBB”分支跳转指令。vAA寄存器为 switch分支中需要判断的值， BBBBBBBB脂向一个 packed-switch- payload格式的偏移表，表中的值是有规律递增的。</p>
<p>“ sparse- switch VAA,+ BBBBBBBB”分支跳转指令。vAA寄存器为 switch分支中需要判断的值， BBBBBBBB指向一个 sparse-switch- payload格式的偏移表，表中的值是无规律的偏移量。</p>
<h4 id="3）条件跳转-if"><a href="#3）条件跳转-if" class="headerlink" title="3）条件跳转  (if)"></a>3）条件跳转  (if)</h4><p>“if-eq”如果vA等于vB则跳转。Java语法表示为“if(vA==vB)</p>
<p>“if-ne”如果v不等于vB则跳转   Java语法表示为“if(vA！=vB)</p>
<p>“if-lt”如果vA小于vB则跳转      Java语法表示为“if(vA&lt;VB)”</p>
<p>“if-ge”如果vA大于等于vB则跳转  Java语法表示为“if(vA&gt;=vB)</p>
<p>“if-gt”如果vA大于vB则跳转。   Java语法表示为“if(vA&gt;VB)”</p>
<p>“if-le”如果vA小于等于vB则跳转。Java法表示为“if(vA&lt;=vB)</p>
<p>“if -testz vAA,+BBBB”条件跳转指令。拿AA寄存器与0比较,如果比较结果满足或值为0时就跳转到BBBB指定的偏移处。偏移量BBBB不能为0。</p>
<h4 id="if-test类型的指令有以下几条"><a href="#if-test类型的指令有以下几条" class="headerlink" title="if- test类型的指令有以下几条:"></a><strong>if- test类型的指令有以下几条:</strong></h4><p>“ if-eqz如果vAA为0则跳转。Java语法表示为“if(!vAA)”</p>
<p>“if-nez”如果vAA不为0则跳转。Java语法表示为“if(vAA)”</p>
<p>“if-ltz”如果vAA小于0则跳转。Java语表示为“if(vAA&lt;0)”</p>
<p>“if-gez”如果vAA大于等于0则跳转。Java语法表示为“if(vAA&gt;=0)</p>
<p>“if-gtz如果vAA大于0则跳转。Java语法表示为“if(vAA&gt;0)</p>
<p>“if-lez”如果vAA小于等于0则跳转。Java语法表示为“if(vAA&lt;=0)</p>
<p>10、比较指令  对两个寄存器的值进行比较</p>
<p>格式：compkind vAA,vBB,vCC</p>
<p>注：vBB和vCC是两个需要比较的寄存器，并把比较的结果放到vAA寄存器中</p>
<p>“cmpl-float”比较两个单精度浮点数。如果vBB寄存器大于vCC寄存器，则结果为-1,相等则结果为0,小于的话结果为1.</p>
<p>“cmpg-float”比较两个单精度浮点数。如果vBB寄存器大于vCC寄存器，则结果为1,相等则结果为0,小于的话结果为-1。</p>
<p>“cmpl-double”比较两个双精度浮点数。如vBB寄存器对大于vCC寄存器对，则结果为-1,相等则结果为0,小于的话结果为-1。</p>
<p>“cmpg-double””比较两个双精度浮点数。如果vBB寄存器对大于vCC寄存器对，则结果为1,相等则结果为0,小于的话结果为-1。</p>
<p>“cmp-long”比较两个长整型数。如果vBB寄存器大于vCC寄存器，则结果为1,相等则结果为0,小于的话结果为1。</p>
<h3 id="11、字段操作指令-用来对对象实例的字段进入读写操作"><a href="#11、字段操作指令-用来对对象实例的字段进入读写操作" class="headerlink" title="11、字段操作指令   用来对对象实例的字段进入读写操作"></a>11、字段操作指令   用来对对象实例的字段进入读写操作</h3><p>1）普通字段指令前缀为i，静态字段的指令前缀为是s。例：iget 、iput</p>
<p>2）根据访问字段类型不同，字段操作指令后面会紧跟字段类型的后缀。例i  get-byte读取实例字段的值的类型为字节类型、iput-short 设置实例字段的值类型为短整型。</p>
<p>3）普通字段指令：iget、iget-wide、iget-object、iget-boolean、iget-byte、iget-char、iget-short、iput、iput-wide、iput-object、iput-boolean、iput-byte、iput-char、iput-short。</p>
<p>4）静态字段操作指令：sget、sget-wide、sget-object、sget-boolean、sget-byte、sget-char、sget-short、sput、sput-wide、sput-object、sput-boolean、sput-byte、sput-char、sput-short。</p>
<p>12、方法调用指令  负责调用类实例  invoke</p>
<p>格式：“nvokek-ind{vC,vD,vE,vF,vG},meth@BBBB”、“invokekind/rangce{vCCCC..vNNNN},meth@B         BBB”两类,两类指令在作用上并无不同,只是后者在设置参数寄存器时使用了range来指定寄存器的范围。</p>
<p>13、数据转换指令    将一种类型的数值转换成另一种类型。</p>
<p>格式：unop,vA,vB   vB寄存器或vB寄存器对存放需要转换的数据，转换后的结果保存在vA寄存器或vA寄存器中。</p>
<p>“neg-int”对整型数求补。 </p>
<p>“not-int”对整形数求反。 </p>
<p>“neg-long”对长整型数求补。</p>
<p>“not-long”对长整型数求反。</p>
<p>“neg-float”对单精度浮点数求补。 </p>
<p>“neg-double”对双精度浮点型数求补。</p>
<p>“int-to-long”将整型换为长整型。</p>
<p>“int-to-float”将数转换为单精度浮点型 。</p>
<p>“int.-to-double”将整型数转换为双精度浮点型 。</p>
<p>“long-to-int”将长整型数转换为整型。</p>
<p>“long-to-float”长型数转换为单精度浮点型。</p>
<p>“long-to- double”将长型数转换为双精度浮点型。</p>
<p>“float-to-int”将单精度点型数转换为整型。</p>
<p>“float-o-long”将单精度浮点型数转换为长整型。</p>
<p>“float-to-double将单精度浮点型数转换为双精度浮点型。</p>
<p>“double-to-int”将双精度浮点型数转换为整型。</p>
<p>“double-to-long”将双精度浮点型数转换为长型。 </p>
<p>“double.-to-float”将双精度浮点型数转换为单精度浮点型 。</p>
<p>“int-to-byte”将整型转换为字节型。</p>
<p>“int-to-char”将整形转换为字符串。</p>
<p>“int-to-short”将整型转换为短整型。</p>
<p>14、数据运算指令</p>
<p>包括算数运算指令和逻辑运算指令</p>
<p>数据运算指令有如下四类</p>
<p>1)binop vAA，vBB，vCC＂将vBB寄存器与vCC寄存器进行运算，结果保存到AA寄存器。</p>
<p>2)binop/2 addr vA，vB”将vA寄存器与vB寄存器进行运算，结果保存到vA寄存器 。</p>
<p>3)binp/lit6 vA，vB,#+CCCC”将vB寄存器与常量CCCC进行运算，结果保存到vA寄存器。</p>
<p>4)binp/lit VAA， VBB,#+CC＂将vBB寄存器与常量CC进行运算，结果保存到vAA寄存器。</p>
<p>后面3类指令比第1类指令分别多出了2addr、lit6、lit8等指令后缀。</p>
<p><strong>四类指令中基础字节码相同的指令执行的运算操作是类似的。</strong>第1类指令中，根据数据的类型不同会在基础字码后面加上数据类型后缀，如-int或-long分别表示操作的数据类型为整型与长整型。</p>
<p>第一类指令可归类如下</p>
<p>“add-type”vBB寄存器与vCC寄存器值进行加法运算(vBB+vCC)。</p>
<p>“sub-type”vBB寄存器与vCC寄存器值进行减法运算(vBB-vCC)。</p>
<p>“mul-type”vBB寄存器与vCC寄存器值进行乘法运算( vBB x vCC) 。</p>
<p>“div-type”vBB寄存器与vCC寄存器值进行除法运算(vBB/vCC)。</p>
<p>“rem-type＂BB寄存器与vCC寄存器值进行模运算(vBB％vCC)。</p>
<p>“and-type＂vBB寄存器与vCC寄存器值进行与运算( vBB AND vCC)。</p>
<p>“ or-type＂BB寄存器与vCC寄存器值进行或运算( VBB OR VCC)。</p>
<p>“xor-type＂vBB寄存器与CC寄存器值进行异或运算( VBB XOR VCC)。</p>
<p>“shi-type＂vBB寄存器值(有符号数)左移vCC位(vBB＜＜vCC)。 </p>
<p>“shr-type＂wB寄存器值(有符号数)右移vCC位(vBB＞＞CC)。</p>
<p>“ ushr-type＂wBB寄存器值(无符号数)右移vCC位(vBB＞＞vCC)。</p>
<p>其中基础字节码后面的-type可以是-int、-long,-float,-double。</p>
]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>ARM汇编</tag>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Android各版本对应的SDK版本</title>
    <url>/2021/08/15/Android%E5%90%84%E7%89%88%E6%9C%AC%E5%AF%B9%E5%BA%94%E7%9A%84SDK%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="Android各版本对应的SDK版本"><a href="#Android各版本对应的SDK版本" class="headerlink" title="Android各版本对应的SDK版本"></a>Android各版本对应的SDK版本</h2><span id="more"></span>
<table>
<thead>
<tr>
<th>安卓版本</th>
<th align="center">SDK版本</th>
</tr>
</thead>
<tbody><tr>
<td>Android 8.0</td>
<td align="center">26</td>
</tr>
<tr>
<td>Android 7.1</td>
<td align="center">25</td>
</tr>
<tr>
<td>Android 7.0</td>
<td align="center">24</td>
</tr>
<tr>
<td>Android 6.0</td>
<td align="center">23</td>
</tr>
<tr>
<td>Android 5.1</td>
<td align="center">22</td>
</tr>
<tr>
<td>Android 5.0</td>
<td align="center">21</td>
</tr>
<tr>
<td>Android 4.4</td>
<td align="center">19</td>
</tr>
<tr>
<td>Android 4.3</td>
<td align="center">18</td>
</tr>
<tr>
<td>Android 4.2, 4.2.2</td>
<td align="center">17</td>
</tr>
<tr>
<td>Android 4.1, 4.1.1</td>
<td align="center">16</td>
</tr>
<tr>
<td>Android 4.0.3, 4.0.4</td>
<td align="center">15</td>
</tr>
<tr>
<td>Android 4.0, 4.0.1, 4.0.2</td>
<td align="center">14</td>
</tr>
<tr>
<td>Android 3.2</td>
<td align="center">13</td>
</tr>
<tr>
<td>Android 3.1.x</td>
<td align="center">12</td>
</tr>
<tr>
<td>Android 3.0.x</td>
<td align="center">11</td>
</tr>
<tr>
<td>Android 2.3.4</td>
<td align="center">10</td>
</tr>
<tr>
<td>Android 2.3.3</td>
<td align="center">10</td>
</tr>
<tr>
<td>Android 2.3.2</td>
<td align="center">9</td>
</tr>
<tr>
<td>Android 2.3.1</td>
<td align="center">9</td>
</tr>
<tr>
<td>Android 2.3</td>
<td align="center">9</td>
</tr>
<tr>
<td>Android 2.2.x</td>
<td align="center">8</td>
</tr>
<tr>
<td>Android 2.1.x</td>
<td align="center">7</td>
</tr>
<tr>
<td>Android 2.0.1</td>
<td align="center">6</td>
</tr>
<tr>
<td>Android 2.0</td>
<td align="center">5</td>
</tr>
<tr>
<td>Android 1.6</td>
<td align="center">4</td>
</tr>
<tr>
<td>Android 1.5</td>
<td align="center">3</td>
</tr>
<tr>
<td>Android 1.1</td>
<td align="center">2</td>
</tr>
<tr>
<td>Android 1.0</td>
<td align="center">1</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Xposed框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Frida——Java层hook方法</title>
    <url>/2021/10/15/Frdia%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94hook%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="Frdia框架——hook方法详解"><a href="#Frdia框架——hook方法详解" class="headerlink" title="Frdia框架——hook方法详解"></a>Frdia框架——hook方法详解</h3><span id="more"></span>
<h4 id="Hook普通方法"><a href="#Hook普通方法" class="headerlink" title="Hook普通方法"></a>Hook普通方法</h4><p>普通方法包含静态方法、公开方法、私有方法。</p>
<pre><code class="javascript">Java.perform(function()&#123;
    var MainActivity=Java.use(&#39;com.example.frida_new1.MainActivity&#39;);//完整包名（注意大小写）
    MainActivity.getCalc.implementation=function(a,b)&#123;
        send(&#39;Hook start....&#39;);
        send(arguments[0]);
        send(b);//两种打印参数的方式
        var num=this.getCalc(a,b); 
        send(num);
        return num;
    &#125;
   &#125;);
</code></pre>
<p>详解：arguments[n]在js中相当于类数组对象，在function(a,b)中参数既可以用a、b来表示，也可以用arguments来表示。虽然function指代getCalc方法，但仍然可以在function中调用包中的其他函数，只是在function中可以对getCalc的方法进行参数调整和改变。</p>
<h4 id="hook构造方法"><a href="#hook构造方法" class="headerlink" title="hook构造方法"></a>hook构造方法</h4><p>大致方法和普通方法相同。因为构造方法与报名相同，所以不需要Util.Util这种写法（我试过直接用构造方法名，直接报错了。。。）构造方法有特有的表示方法：</p>
<pre><code>类名.$init //这里的$init就表示构造方法。
</code></pre>
<p>具体代码：</p>
<pre><code class="javascript">Java.perform(function()&#123;
        var money=Java.use(&#39;com.example.frida_new1.Money&#39;);
        money.$init.implementation=function(a,b)&#123;
            send(&#39;hook到Money构造函数&#39;);
            send(arguments[0]);
            send(b);
            return this.$init(10000,&quot;美元&quot;);//用this.方法名来表示需要调用的方法（直接用不明确，会报错）
        &#125;
    &#125;);
</code></pre>
<p>修改函数时，注意参数类型。</p>
<h4 id="hook重载方法"><a href="#hook重载方法" class="headerlink" title="hook重载方法"></a>hook重载方法</h4><p>和普通方法不同的区别是在寻找方法时使用：</p>
<pre><code>Utils.cz.overload(&quot;int&quot;).implementation=function(参数)
</code></pre>
<p>详解：cz为重载方法名，overload为注明此方法为重载方法并在括号中标明所要hook的重载方法中的参数，并传入。例如:需要hook的重载方法有一个int参数：overload(“int”)即可。但是String类型有点特殊，需要写为overload(“java.lang.String”)因为overload中需要标明的实际是类型所处的全路径。</p>
<pre><code class="javascript">Java.perform(function()&#123;
        var Utils=Java.use(&#39;com.example.frida_new1.Utils&#39;);
        Utils.cz.overload(&quot;int&quot;,&quot;java.lang.String&quot;).implementation=function(a,b)&#123;
            send(&#39;hook成功！&#39;);
            send(arguments[0]);
            send(b);
            return this.cz();
        &#125;
    &#125;);
</code></pre>
<h5 id="hook方法的所有重载"><a href="#hook方法的所有重载" class="headerlink" title="hook方法的所有重载"></a>hook方法的所有重载</h5><p>获取一方法的所有重载方法，只需utils.test.overloads，其余操作和正常重载方法相同。</p>
<pre><code class="js">Java.perform(function()&#123;
        var utils=Java.use(&#39;com.example.frida_new1.Utils&#39;);
        console.log(utils.test.overloads.length);//获取重载方法的个数
        for(var i=0;i&lt;utils.test.overloads.length;i++)&#123;
            utils.test.overloads[i].implementation=function()&#123;
                console.log(arguments);//arguments是一个储存所有重载方法的参数
                return this.test.apply(this,arguments);//只用apply将不同的重载方法返回对应的参数
                //如果apply中参数有arguments，则直接返回。
                //如果apply中只有this一个参数，则循环重载方法的个数次。
            &#125;
        &#125;
   &#125;);
</code></pre>
<p>如果只想修改无参的重载方法，只需加上一个判断：</p>
<pre><code class="js">if(arguments.length==0)&#123;
     return &quot;hook到没有参数的重载方法&quot;;
&#125;
</code></pre>
<h4 id="hook自定义参数"><a href="#hook自定义参数" class="headerlink" title="hook自定义参数"></a>hook自定义参数</h4><p>自定义参数类型时，对于对象参数可以直接调用对象中的方法。如果需要更改参数时，需要重新实例化一个对象来返回：</p>
<pre><code class="javascript">var 变量名=对象类名.$new(构造参数) 如：var mon =money.$new(123456,&quot;港币&quot;);
</code></pre>
<p>注意如果是重载方法中参数为某一对象，在overload中需要标明对象类 的全路径。例如：</p>
<pre><code class="javascript">Utils.method.overload(&quot;com.example.frida_new1.Money&quot;).implementation=function(参数)
</code></pre>
<pre><code class="javascript">Java.perform(function()&#123;
        var Utils=Java.use(&#39;com.example.frida_new1.Utils&#39;);
        var money=Java.use(&#39;com.example.frida_new1.Money&#39;);
        Utils.test.implementation=function(a)&#123;
            send(&#39;hook到对象参数&#39;);
            send(a.getInfo());
            var mon =money.$new(123456,&quot;港币&quot;);
            send(mon.getInfo());
            return mon.getInfo();//这里返回值可更改为this.test(mon)，要注意返回值的参数类型！！
        &#125;
&#125;);
</code></pre>
<h4 id="对象参数属性的修改"><a href="#对象参数属性的修改" class="headerlink" title="对象参数属性的修改"></a>对象参数属性的修改</h4><p>在获取某一实例对象的属性时不能直接通过”类名.变量名”的方法来直接获取。需要表示为“类名.变量名.value”</p>
<pre><code class="javascript">Java.perform(function()&#123;
        var Utils=Java.use(&#39;com.example.frida_new1.Utils&#39;);
        var money=Java.use(&#39;com.example.frida_new1.Money&#39;);
        Utils.test.overload(&quot;com.example.frida_new1.Money&quot;).implementation=function(a)&#123;
            send(&#39;hook到对象参数&#39;);
            var mon =money.$new(123456,&quot;港币&quot;);
            send(mon.getInfo());
            mon.name.value=&quot;英镑&quot;;
            send(mon.name.value);
            return mon.getInfo();
        &#125;
    &#125;);
</code></pre>
<h4 id="java反射（对参数属性的修改）"><a href="#java反射（对参数属性的修改）" class="headerlink" title="java反射（对参数属性的修改）"></a>java反射（对参数属性的修改）</h4><p>使用反射的主要作用是可以让其他语言去调用java语言。基本思想：先找类，再找方法，再调用方法。</p>
<pre><code class="javascript">Java.perform(function()&#123;
        var Utils=Java.use(&#39;com.example.frida_new1.Utils&#39;);
        var money=Java.use(&#39;com.example.frida_new1.Money&#39;);
        var clazz=Java.use(&#39;java.lang.Class&#39;);//定义一个类的构造器
        Utils.test.overload(&quot;com.example.frida_new1.Money&quot;).implementation=function(a)&#123;
            var mon =money.$new(123456,&quot;港币&quot;);
            send(mon.getInfo());
            var num=Java.cast(mon.getClass(),clazz).getDeclaredField(&#39;num&#39;);
            //cast中第一个参数是getClass获取类id，（对象所处的类）
            //getDeclaredField(&#39;&#39;)用来获取字段id,参数为变量名
            var name=Java.cast(mon.getClass(),clazz).getDeclaredField(&#39;name&#39;);
            name.setAccessible(true);
            num.setAccessible(true);//设置属性，不修改app会崩溃
            var Value=num.get(mon);//获取类传到该变量中
            console.log(Value);
            //这里直接使用send()无法成功打印
            var v1=name.get(mon);
            console.log(v1);
            //send(Value);这里直接用send无法输出
            num.setInt(mon,5000);
            name.set(mon,&quot;英镑&quot;);//修改变量使用set...()方法：setInt(),set()
            send(mon.getInfo());
            return mon.getInfo();
        &#125;
&#125;);
</code></pre>
<p>注：hook onCreat方法时应该在结尾继续执行该方法，因为onCreat在程序中是一直执行的。在末尾加上 this.onCreat()</p>
<h4 id="hook内部类"><a href="#hook内部类" class="headerlink" title="hook内部类"></a>hook内部类</h4><p>内部类：在一个类中定义一个新的类。和直接引用不同的是需要在声明类的时候在主类和内部类中加“$”符号。其余写法完全相同。</p>
<pre><code class="javascript"> Java.perform(function()&#123;
        var intheclass=Java.use(&#39;com.example.frida_new1.Utils$intheclass&#39;);
        console.log(intheclass);
        intheclass.$init.implementation=function(a,b)&#123;
            send(&#39;Hook start....&#39;);
            send(a);
            send(b);
            b=6666
            a=&quot;iu&quot;
            send(&quot;修改后：&quot;+a+&quot; &quot;+b);
            return this.$init(a,b);
        &#125;
   &#125;);
</code></pre>
<h4 id="hook匿名类"><a href="#hook匿名类" class="headerlink" title="hook匿名类"></a>hook匿名类</h4><p>匿名类：一个类中包含另一个类，且不需要任何类名直接实例化（没有类名）。主要用于创建一个对象来执行特定的任务，是代码更加简洁。一般匿名类只用一次。首先在smali代码中找到匿名类名（带有$）,其余代码与普通方法类似</p>
<h4 id="枚举所有的类和类的所有方法。"><a href="#枚举所有的类和类的所有方法。" class="headerlink" title="枚举所有的类和类的所有方法。"></a>枚举所有的类和类的所有方法。</h4><p>枚举所有的类在js中有一个固定的函数：enumerateLoadedClasses，具体使用方法如下：</p>
<pre><code class="js">Java.perform(function()&#123;
    //这样枚举会列举出该模拟器中正在运行的所有进程
        Java.enumerateLoadedClasses(&#123;//枚举加载所有的类
            onMatch:function(name,handle)&#123;//输出
                console.log(name);
            &#125;,
            onComplete:function()&#123;//枚举结束之后调用，该函数只会调用一次
            &#125;
        &#125;);
    &#125;);
</code></pre>
<p>如果在onMatch中进行选择，指定包中的类，则会筛选输出指定类名。</p>
<pre><code class="js">Java.perform(function()&#123;
        Java.enumerateLoadedClasses(&#123;//枚举加载所有的类
            onMatch:function(name,handle)&#123;//输出
                if(name.indexOf(&quot;com.example.frida_new1&quot;)!=-1)&#123;
                    console.log(name);
                    var clazz =Java.use(name);
                    console.log(clazz);
                    var methods=clazz.class.getDeclaredMethods();
                    for(var i=0;i&lt;methods.length;i++)&#123;
                        console.log(methods[i]);
                    &#125;
                &#125;
            &#125;,
            onComplete:function()&#123;//枚举结束之后调用，该函数只会调用一次
            
            &#125;
        &#125;);
    &#125;);
&quot;&quot;&quot;
</code></pre>
<p>枚举所有的方法使用clazz.class.getDeclaredMethods()；</p>
<pre><code class="javascript">var clazz =Java.use(name);
console.log(clazz);
var methods=clazz.class.getDeclaredMethods();
for(var i=0;i&lt;methods.length;i++)&#123;
       console.log(methods[i]);
&#125;
</code></pre>
<h4 id="Java层打印函数堆栈定位关键代码"><a href="#Java层打印函数堆栈定位关键代码" class="headerlink" title="Java层打印函数堆栈定位关键代码"></a>Java层打印函数堆栈定位关键代码</h4><p>在xposed中打印函数堆栈一般使用：</p>
<pre><code class="java">log.d(&quot;TAG&quot;,&quot;MSG&quot;,new Trowable());
</code></pre>
<p>在frida中一般不使用，而使用Log.getStackTranceString()方法。（该方法也可以打印信息）。</p>
<p> java.cast()：强制类型转换。                                                                                                                                                  </p>
<p>java.openClassFile()；    //注入dex文件                                                                                                                                                  </p>
<p> java.registerClass()    //在Frida中注册一个类写进app，很少用到。                                                                               </p>
<p>java.array();//构造任意类型的数组。</p>
<h4 id="frida注入多dex文件"><a href="#frida注入多dex文件" class="headerlink" title="frida注入多dex文件"></a>frida注入多dex文件</h4><p>当hook比较复杂时（需要大量使用java函数，想为app添加大量函数），很多函数不方便引入js中使用，就需要正向的java函数来注入到frida中，此时引入注入dex文件这一方法，方便hook。<strong>首先需要获取dex文件</strong>，建议直接将所需要的函数在另一个app中实现，打包成apk分离出dex文件即可（分离出dex文件后需要把他放在adnroid的缓存区：“adb push 文件路径 、data/local/tmp/xxx.dex）。再使用openClassFile函数来打开这个文件。获取到这个包后可以直接调用包中 的函数。相当于正向调用。</p>
<pre><code class="js">Java.perform(function()&#123;
        Java.openClassFile(&quot;/data/local/tmp/fridadex.dex&quot;).load();
        var frida=Java.use(&quot;简单实现函数的打包的apk的包名&quot;);//dex中的函数所在类名
        var main=Java.use(&quot;com.example.frida_new1.Money&quot;);//开始hook
        main.fridadex.implementation=function(a,b)&#123;
            var cal=frida.xxx(a,b);
            send(cal);
            return cal;
        &#125;
    &#125;);
</code></pre>
<h4 id="Frida-server端口启动与非标准端口启动"><a href="#Frida-server端口启动与非标准端口启动" class="headerlink" title="Frida-server端口启动与非标准端口启动"></a>Frida-server端口启动与非标准端口启动</h4><p>启动Frida-server一般采用默认端口：</p>
<pre><code>adb forward tcp:27042 tcp:27042
adb forward tcp:27043 tcp:24043
</code></pre>
<p>为了防止被检测，会使用非标准端口：                                                                                                    </p>
<p> 1、启动frida-server时使用”./data/local/tmp/frida-server -l 127.0.0.1:9999 “                                            </p>
<p> 2、转发端口时”adb forward tcp:9999”                                                                                                         </p>
<p> 3、在frida中修改为：</p>
<pre><code class="python">process = frida.get_device_manager().add_remote_device(&#39;127.0.0.1:9999&#39;).attch(&#39;Frida_new1&#39;)
</code></pre>
]]></content>
      <categories>
        <category>Frida框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Frida框架</tag>
        <tag>hook</tag>
      </tags>
  </entry>
  <entry>
    <title>Xposed——hook方法学习</title>
    <url>/2021/08/31/Xposed%20%E2%80%94hook%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>Xposed是基于java层的hook框架，在不修改apk源码的情况下，编写自己的模块来改变apk的行为。以下总结了常见的Xposed的hook方法：</p>
<span id="more"></span>

<h3 id="hook普通方法"><a href="#hook普通方法" class="headerlink" title="hook普通方法"></a>hook普通方法</h3><p>创建一个类继承IXposedHookLoadPackage，修改 handleLoadPackage方法，首先要判断是否为特定的包。</p>
<pre><code class="java">public void handleLoadPackage(XC_LoadPackage.LoadPackageParam Param) throws Throwable &#123;
    if(Param.packageName.equals(&quot;com.example.xposed_new3&quot;))&#123;......&#125;
&#125;
</code></pre>
<p>hook普通方法调用的函数都是<strong>XposedHelpers.findAndHookMethod</strong></p>
<pre><code class="java">XposedHelpers.findAndHookMethod(
className(包名+类名),
Param.classLoader(固定参数),
methodName(被hook的函数名)
**.class(函数的参数),
new XC_MethodHook()&#123;&#125;
)
</code></pre>
<h4 id="XC-MethodHook方法详解"><a href="#XC-MethodHook方法详解" class="headerlink" title="XC_MethodHook方法详解"></a>XC_MethodHook方法详解</h4><p><img src="https://i.loli.net/2021/09/02/Uk2MhKwNJPtTLSa.png" alt="QQ截图20210901190645.png"></p>
<p>hook普通方法的主要作用是打印各种参数信息，或者修改某些参数使其直接通过程序。</p>
<h3 id="hook匿名内部类"><a href="#hook匿名内部类" class="headerlink" title="hook匿名内部类"></a>hook匿名内部类</h3><p>匿名内部类一般为普通方法，所以仍然用findAndHookMethod的hook方法。</p>
<p>注：匿名内部类辨别方法：在smali代码中一个类为一个文件，且匿名内部类后缀会加上”$”符号，在工程管理器中直接找出相关类。</p>
<blockquote>
<p>Lcom/example/xposed_new4/MainActivity$1</p>
</blockquote>
<pre><code class="java">@Override
public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable &#123;
    if(loadPackageParam.packageName.equals(&quot;com.example.xposed_new4&quot;))&#123;
        XposedHelpers.findAndHookMethod(
        &quot;com.example.xposed_new4.MainActivity$1&quot;,
        loadPackageParam.classLoader,
        &quot;onClick&quot;,
        View.class,
        new XC_MethodHook() &#123;
            @Override
            protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123;
                super.beforeHookedMethod(param);
                View v=(View)param.args[0];
                XposedBridge.log(&quot;view:&quot;+v.getId());
            &#125;
         &#125;);
     &#125;
&#125;
</code></pre>
<p>在findAndHookMethod方法中的包名类名参数使用smali代码中的包名加类名，其余操作与普通方法hook相同。</p>
<h3 id="Xposed—java-反射"><a href="#Xposed—java-反射" class="headerlink" title="Xposed—java 反射"></a>Xposed—java 反射</h3><p> java反射主要作用为突破修饰符的限制，如获取私有方法和私有字段。</p>
<p>以hook某一私有控件为例</p>
<pre><code class="java">//获取类
Class&lt;?&gt; clazz=param.thisObject.getClass();
//获取字段
Field field=clazz.getDeclaredField(&quot;Text&quot;);
//设置可见
field.setAccessible(true);

EditText ed_sn= (EditText) field.get(param.thisObject);//把类中的控件参数传给ed_sn
XposedBridge.log(&quot;输入结果为：&quot;+ed_sn.getText().toString().trim());
//修改编辑框
ed_sn.setText(&quot;L61q4_cheng&quot;);
</code></pre>
<p>hook某一私有方法</p>
<pre><code class="java">//获取方法
Method method=clazz.getDeclaredMethod(&quot;MethodName&quot;,new Class[]&#123;.class,.class...&#125;);
//显示可见
method.setAccessible(true);
//调用方法
返回值=method.invoke(param.thisObject,new Object()&#123;...&#125;);//调用函数的参数
</code></pre>
<h3 id="hook主动调用"><a href="#hook主动调用" class="headerlink" title="hook主动调用"></a>hook主动调用</h3><p>主动调用，直接调用apk中的函数来实现hook操作，方便对数据进行直接操作。主动调用函数为XposedHelpers。该方法一般用于获取某一数据来通过某一入口，而不是直接修改方法的返回值。Xposed通过主动调用可以直接使用Android项目中某些方法，使其可以有更强大的功能。</p>
<h4 id="XposedHelpers方法详解"><a href="#XposedHelpers方法详解" class="headerlink" title="XposedHelpers方法详解"></a>XposedHelpers方法详解</h4><pre><code class="java">XposedHelpers.callMethod();//调用普通方法
XposedHelpers.callStaticMethod();//调用静态方法
</code></pre>
<pre><code class="java">XposedHelpers.callMethod(
    param.getClass(),//固定句式
    &quot;methodName&quot;//需要主动调用的方法名
    new Object[]&#123;...,...&#125;,//大括号中为调用函数中的参数，
)
</code></pre>
<p>在调用方法之前，可将程序中对参数的操作直接复制过来，例如加密操作，格式操作。</p>
<p>如果该方法有返回值且需要获取，可将该方法直接用在某一变量上，例如：</p>
<pre><code class="java">String str=(String)XposedHelpers.callMethod(
    param.getClass(),
    &quot;methodName&quot;
    new Object[]&#123;...,...&#125;,
)
param.args[1]=str.toString();
</code></pre>
<h3 id="Xposed—hook静态变量"><a href="#Xposed—hook静态变量" class="headerlink" title="Xposed—hook静态变量"></a>Xposed—hook静态变量</h3><p>实例变量在每一份实例出来的类中都有不同的值，先有对象才有实例变量，因此在没有对象之前是不能hook修改实例变量。在内存中静态变量不会改变。因此可以在对象之前hook。</p>
<p>故hook静态变量不需要获取类对象，直接修改类中私有静态变量。hook的方法有XposedHelpers，以变量类型Int为例。</p>
<pre><code class="java">final Class&lt;?&gt; clazz= XposedHelpers.findClass(
            &quot;com.example.xposed_new5.MainActivity&quot;,
            loadPackageParam.classLoader);//方便起见提前赋给clazz
XposedHelper.setStaticIntField(clazz,&quot;变量名&quot;,value(修改的值));
</code></pre>
<pre><code class="java">XposedHelpers.setStaticObjectField();//修改字符串
</code></pre>
<p>注：不同变量类型使用不同方法。</p>
<pre><code class="java">final Class&lt;?&gt;clazz=XposedHelpers.findClass(
        &quot;com.example.xposed_new5.MainActivity&quot;,
        loadPackageParam.classLoader);        
XposedHelpers.setStaticIntField(clazz,&quot;staticInt&quot;,99);
</code></pre>
<h3 id="Xposed—hook构造方法"><a href="#Xposed—hook构造方法" class="headerlink" title="Xposed—hook构造方法"></a>Xposed—hook构造方法</h3><h4 id="Java构造方法"><a href="#Java构造方法" class="headerlink" title="Java构造方法"></a>Java构造方法</h4><p>与类同名，通过关键字new调用，每个类至少有一个或一个以上的构造方法（如果没有定义构造方法，系统会自动定义一个无参数的构造方法）。构造方法可以无参、一个或多个参数，且构造方法没有返回值。例如：</p>
<pre><code class="java">MainActivity()&#123;
&#125;
MainActivity(int a,int b)&#123;
&#125;
MainActivity(String str)&#123;
&#125;
</code></pre>
<h4 id="hook构造方法"><a href="#hook构造方法" class="headerlink" title="hook构造方法"></a>hook构造方法</h4><p>hook构造方法不需要添加方法名，采用的hook方法为XposedHelpers.findAndHookConstructor。</p>
<p>此时不能hook实例变量，因为对象还没有产生。</p>
<h4 id="findAndHookConstructor详解"><a href="#findAndHookConstructor详解" class="headerlink" title="findAndHookConstructor详解"></a>findAndHookConstructor详解</h4><pre><code class="java">final Class&lt;?&gt; clazz=XposedHelpers.findClass(
&quot;com.example.xposed_new6.MainActivity&quot;,//包名加类名
loadPackageParam.classLoader);//固定格式
XposedHelpers.findAndHookConstructor(
clazz,//可以提前定义，也可以直接在这里写出来
int.class,//构造方法的参数
String.class,//无参数也可以不写
new XC_MethodHook()&#123;
//和普通方法写法一样
@Override
protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123;
        XposedBridge.log(&quot;Haha, HookDemo constructed was hooked&quot; );
        &#125;
@Override
protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123;
        super.afterHookedMethod(param);
        &#125;        
&#125;);
</code></pre>
<h3 id="Xposed—hook所有函数遍历所有类"><a href="#Xposed—hook所有函数遍历所有类" class="headerlink" title="Xposed—hook所有函数遍历所有类"></a>Xposed—hook所有函数遍历所有类</h3><p>对于动态dex文件可以采用这种方法来hook。</p>
<pre><code class="java"> XposedHelpers.findAndHookMethod(
        ClassLoader.class,
        &quot;isok&quot;,
        String.class,
        new XC_MethodHook() &#123;
                @Override
                protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123;
                     super.afterHookedMethod(param);
                     Class&lt;?&gt; clazz=(Class&lt;?&gt;) loadPackageParam.getResult();
                     XposedBridge.log(&quot;Clazz：&quot;+clazz.getName());
                     &#125;
         &#125;
&#125;);
</code></pre>
<h3 id="通过hook主动调用获取相关数据"><a href="#通过hook主动调用获取相关数据" class="headerlink" title="通过hook主动调用获取相关数据"></a>通过hook主动调用获取相关数据</h3><h4 id="获取类"><a href="#获取类" class="headerlink" title="获取类"></a>获取类</h4><pre><code class="java">Class&lt;?&gt; clazz=param.thisObject.getClass();
</code></pre>
<h4 id="对类进行操作-获取字段"><a href="#对类进行操作-获取字段" class="headerlink" title="对类进行操作(获取字段)"></a>对类进行操作(获取字段)</h4><pre><code class="java">Field[] fields=clazz.getDeclaredFields();
for(Field field:fields)&#123;
     XposedBridge.log(&quot;字段名称：&quot;+field.getName());
&#125;
</code></pre>
<h4 id="获取类中的所有方法"><a href="#获取类中的所有方法" class="headerlink" title="获取类中的所有方法"></a>获取类中的所有方法</h4><pre><code class="java">Method[] methods=clazz.getDeclaredMethods();
for(Method method:methods)
&#123;
      XposedBridge.log(&quot;方法名称：&quot;+method.getName());
&#125;
</code></pre>
<h4 id="通过主动调用获取普通方法"><a href="#通过主动调用获取普通方法" class="headerlink" title="通过主动调用获取普通方法"></a>通过主动调用获取普通方法</h4><pre><code class="java">XposedHelpers.callMethod(loadPackageParam.getClass(),&quot;methodName&quot;,new Object()&#123;...&#125;);
</code></pre>
<h4 id="通过主动调用获取静态方法"><a href="#通过主动调用获取静态方法" class="headerlink" title="通过主动调用获取静态方法"></a>通过主动调用获取静态方法</h4><pre><code class="java">Class&lt;?&gt; clazz1=XposedHelpers.findClass(
    &quot;com.example.xposed_new7.MainActivity&quot;,
    loadPackageParam.classLoader);
XposedHelpers.callStaticMethod(clazz1,&quot;methodName&quot;,new Object()&#123;...&#125;);
</code></pre>
<h4 id="通过主动调用获取普通字段（不是方法中的特定字段）"><a href="#通过主动调用获取普通字段（不是方法中的特定字段）" class="headerlink" title="通过主动调用获取普通字段（不是方法中的特定字段）"></a>通过主动调用获取普通字段（不是方法中的特定字段）</h4><pre><code class="java">XposedHelpers.getBooleanField(loadPackageParam.getClass(),&quot;fieldName&quot;);
</code></pre>
<h4 id="获取静态字段"><a href="#获取静态字段" class="headerlink" title="获取静态字段"></a>获取静态字段</h4><pre><code class="java">Class&lt;?&gt; clazz2=XposedHelpers.findClass(
    &quot;com.example.xposed_new7.MainActivity&quot;,
    loadPackageParam.classLoader);
XposedHelpers.getStaticBooleanField(clazz2,&quot;fieldName&quot;);
</code></pre>
<h3 id="Xposed—hook替换函数"><a href="#Xposed—hook替换函数" class="headerlink" title="Xposed—hook替换函数"></a>Xposed—hook替换函数</h3><pre><code class="java">if(loadPackageParam.packageName.equals(&quot;com.example.xposed_new8&quot;))&#123;
            Class&lt;?&gt;clazz=XposedHelpers.findClass(
                &quot;com.example.xposed_new8.MainActivity&quot;,
                loadPackageParam.classLoader);
            XposedHelpers.findAndHookMethod(
                    &quot;com.example.xposed_new8.MainActivity&quot;,
                    loadPackageParam.classLoader,
                    &quot;ButtonTest1&quot;,
                    new XC_MethodReplacement() &#123;
                    @Override
                    protected Object replaceHookedMethod(MethodHookParam methodHookParam) throws Throwable &#123;
                            XposedBridge.log(&quot;方法替换成功&quot;);
                            XposedHelpers.callMethod(clazz,&quot;ButtonTest2&quot;);//主动调用ButtonTest2
                            return null;
                        &#125;
                    &#125;
            );
&#125;
</code></pre>
<h3 id="Xposed—hook多DEX"><a href="#Xposed—hook多DEX" class="headerlink" title="*Xposed—hook多DEX"></a>*Xposed—hook多DEX</h3><p>在一个apk中有多个dex文件时，在apk打包的时候优先加载主dex文件，会优先有些类hook不到，采用attach方法来解决。</p>
<pre><code class="java">XposedHelpers.findAndHookMethod(
        Application.class,
        &quot;attach&quot;,
        Context.class,
        new XC_MethodHook() &#123;
                 @Override
                 protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123;
                 super.beforeHookedMethod(param);
                 Context context= (Context) param.args[0];
                 ClassLoader loader=context.getClassLoader();
                 XposedHelpers.findAndHookMethod(
                         &quot;com.example.xposed_new8.MainActivity&quot;,
                         loader,
                         &quot;ButtonTest1&quot;,
                         new XC_MethodHook() &#123;
                                 @Override
                                 protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123;
                                            super.beforeHookedMethod(param);
                              &#125;
                         &#125;
                );
           &#125;
       &#125;
);
</code></pre>
]]></content>
      <categories>
        <category>Xposed框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>hook</tag>
        <tag>Xposed框架</tag>
      </tags>
  </entry>
  <entry>
    <title>加密算法（SHA-1篇）</title>
    <url>/2021/07/27/SHA-1/</url>
    <content><![CDATA[<h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a><strong>概述</strong>：</h3><p>SHA-1是一种<strong>数据加密算法</strong>，该算法的思想是接收一段明文，然后以一种<strong>不可逆</strong>的方式将它转换成一段（通常更小）密文，也可以简单的理解为取一串输入码（称为预映射或信息），并把它们转化为长度较短、位数固定的输出序列即散列值（也称为信息摘要或信息认证代码）的过程。 </p>
<p>可以生成一个被称为信息摘要的160位（20字节）散列值，散列值通常的呈现形式位40个十六进制数。</p>
<span id="more"></span>
<p>该算法输入报文的长度不限，产生的输出是一个160位的报文摘要。输入是按512 位的分组进行处理的。SHA-1是<strong>不可逆的</strong>、防冲突，并具有良好的雪崩效应。</p>
<p>数字签名的原理是将要传送的明文通过一种函数运算（Hash）转换成报文摘要（不同的明文对应不同的报文摘要），报文摘要加密后与明文一起传送给接受方，接受方将接受的明文产生新的报文摘要与发送方的发来报文摘要解密比较，比较结果一致表示明文未被改动，如果不一致表示明文已被篡改。</p>
<h3 id="简单文字描述："><a href="#简单文字描述：" class="headerlink" title="简单文字描述："></a><strong>简单文字描述：</strong></h3><h4 id="客户端："><a href="#客户端：" class="headerlink" title="客户端："></a><strong>客户端：</strong></h4><p>在APP 与 后端服务器接口调用的时候，将需要传输的参数进行关键参数（如：String A,String B）进行SHA1加密，获取加密之后的摘要(C)；然后在接口调用的时候将参数原文（A,B） 和 加密的摘要（C） 一起传输给后台服务器；</p>
<h4 id="服务器："><a href="#服务器：" class="headerlink" title="服务器："></a><strong>服务器：</strong></h4><p>后台接口接受相关参数，然后将（A,B） 在后台进行SHA1加密，获取加密摘要D,最后将D与C进行比较，如果C == D ，则 A和B 在传输过程中参数没有被窃取改变；如果 C != D，则说明A和B已经在传输过程中发生了改变，最好不要使用！</p>
<p><strong>注</strong>：需要在前后端共同定义一个加密额外秘钥，在进行SHA1加密的过程中添加进去，这样即使在客户端拦截到我们需要传输的参数，进行SHA1 加密，但是由于其不知道 秘钥，所以进行SHA1加密出来的摘要肯定和后端用相关参数、秘钥计算出来的结果不同。</p>
<p><strong>关键SHA-1加密代码简单举例：</strong></p>
<pre><code> public static String createSignature(String... arr) &#123;
        try &#123;
            Arrays.sort(arr);            
            StringBuilder content = new StringBuilder();
            for (int i = 0; i &lt; arr.length; i++) &#123;
                content.append(arr[i]);
            &#125;
            MessageDigest md = MessageDigest.getInstance(&quot;SHA-1&quot;);           
            byte[] digest = md.digest(content.toString().getBytes());
            return byteToStr(digest);
        &#125; catch (Exception e) &#123;  
        &#125;
        return null;
&#125;
</code></pre>
<h3 id="算法原理："><a href="#算法原理：" class="headerlink" title="算法原理："></a><strong>算法原理：</strong></h3><h4 id="1、将消息摘要转换成位字符串"><a href="#1、将消息摘要转换成位字符串" class="headerlink" title="1、将消息摘要转换成位字符串"></a><strong>1、将消息摘要转换成位字符串</strong></h4><p>因为在SHA-1算法中，<strong>它的输入必须为位</strong>，所以我们首先要将其转化为<strong>位字符串</strong>，我们以“abc”字符串来说明问题，因为’a’=97, ‘b’=98, ‘c’=99，所以将其转换为位串后为：01100001 01100010 01100011</p>
<h4 id="2、对转换后的位字符串进行补位操作"><a href="#2、对转换后的位字符串进行补位操作" class="headerlink" title="2、对转换后的位字符串进行补位操作"></a><strong>2、对转换后的位字符串进行补位操作</strong></h4><p>SHA-1算法标准规定，必须对消息摘要进行<strong>补位操作</strong>，即将输入的数据进行填充，使得数据长度对512求余的结果为448，填充比特位的最高位补一个1，其余的位补0，如果在补位之前已经满足对512取模余数为448，也要进行补位，在其后补一位1即可。总之，补位是至少补一位，最多补512位，我们依然以“abc”为例，其补位过程如下：</p>
<p>初始的信息摘要：01100001 01100010 01100011</p>
<p>第一步补位：     01100001 01100010 01100011 1</p>
<p>….. ……</p>
<p>补位最后一位：  01100001 01100010 01100011 10…….0(后面补了423个0)</p>
<p>而后我们将补位操作后的信息摘要转换为十六进制，如下所示：</p>
<p>61626380 00000000 00000000 00000000</p>
<p>00000000 00000000 00000000 00000000</p>
<p>00000000 00000000 00000000 00000000</p>
<p>00000000 00000000</p>
<h5 id="3、附加长度值"><a href="#3、附加长度值" class="headerlink" title="3、附加长度值"></a><strong>3、附加长度值</strong></h5><p>在信息摘要后面附加64bit的信息，用来表示原始信息摘要的长度，在这步操作之后，信息报文便是512bit的倍数。通常来说用一个64位的数据表示原始消息的长度，如果消息长度不大于2^64，那么前32bit就为0，在进行附加长度值操作后，其“abc”数据报文即变成如下形式：</p>
<p>61626380 00000000 00000000 00000000</p>
<p>00000000 00000000 00000000 00000000</p>
<p>00000000 00000000 00000000 00000000</p>
<p>00000000 00000000 00000000 00000018</p>
<p>因为“abc”占3个字节，即24位 ，换算为十六进制即为0x18。</p>
<p><strong>4、初始化缓存</strong></p>
<p>一个160位MD缓冲区用以保存中间和最终散列函数的结果。它可以表示为5个32位的寄存器(H0,H1,H2,H3,H4)。初始化为：</p>
<pre><code>H0 = 0x67452301

H1 = 0xEFCDAB89

H2 = 0x98BADCFE

H3 = 0x10325476

H4 = 0xC3D2E1F0
</code></pre>
<p>如果大家对MD-5不陌生的话，会发现一个重要的现象，其前四个与MD-5一样，但不同之处为存储为big-endien format.</p>
<p><strong>5、计算消息摘要</strong></p>
<p>在计算报文之前我们还要做一些基本的工作，就是在我们计算过程中要用到的方法，或定义。</p>
<p>(1)循环左移操作符Sn(x),x是一个字，也就是32bit大小的变量，n是一个整数且0&lt;=n&lt;=32。Sn(X) = (X&lt;&lt;n)OR(X&gt;&gt;32-n)</p>
<p>(2)在程序中所要用到的常量，这一系列常量字k(0)、k(1)、…k(79)，将其以十六进制表示如下：</p>
<pre><code>Kt = 0x5A827999  (0 &lt;= t &lt;= 19)

Kt = 0x6ED9EBA1 (20 &lt;= t &lt;= 39)

Kt = 0x8F1BBCDC (40 &lt;= t &lt;= 59)

Kt = 0xCA62C1D6 (60 &lt;= t &lt;= 79)
</code></pre>
<p>(3)所要用到的一系列函数</p>
<pre><code> Ft(b,c,d)  ((b&amp;c)|((~b)&amp;d))  (0 &lt;= t &lt;= 19)

 Ft(b,c,d) (b^c^d)      (20 &lt;= t &lt;= 39)

 Ft(b,c,d) ((b&amp;c)|(b&amp;d)|(c&amp;d))  (40 &lt;= t &lt;= 59)

 Ft(b,c,d) (b^c^d)      (60 &lt;= t &lt;= 79)
</code></pre>
<p>(4)计算</p>
<p>计算需要一个缓冲区，由5个32位的字组成，还需要一个80个32位字的缓冲区。第一个5个字的缓冲区被标识为A，B，C，D，E。80个字的缓冲区被标识为W0, W1,…, W79</p>
<p>另外还需要一个一个字的TEMP缓冲区。</p>
<p>为了产生消息摘要，在第4部分中定义的16个字的数据块M1, M2,…, Mn</p>
<p>会依次进行处理，处理每个数据块Mi 包含80个步骤。</p>
<p>现在开始处理M1, M2, … , Mn。</p>
<p>为了处理 Mi,需要进行下面的步骤</p>
<p>(1). 将 Mi 分成 16 个字 W0, W1, … , W15,  W0 是最左边的字</p>
<p>(2). 对于 t = 16 到 79 令 Wt = S1(Wt-3 XOR Wt-8 XOR Wt- 14 XOR Wt-16).</p>
<p>(3). 令 A = H0, B = H1, C = H2, D = H3, E = H4.</p>
<p>(4) 对于 t = 0 到 79，执行下面的循环</p>
<p>TEMP = S5(A) + ft(B,C,D) + E + Wt + Kt;</p>
<p>E = D; D = C; C = S30(B); B = A; A = TEMP;</p>
<p>(5) 令 H0 = H0 + A,H1 = H1 + B,H2 = H2 + C, H3 = H3 + D, H4 = H4 + E. </p>
<p>在处理完所有的 Mn, 后，消息摘要是一个160位的字符串，以下面的顺序标识</p>
<p>H0 H1 H2 H3 H4.</p>
<p>对于SHA256,SHA384,SHA512。你也可以用相似的办法来计算消息摘要。对消息进行补位的算法完全是一样的。</p>
<h3 id="加密："><a href="#加密：" class="headerlink" title="加密："></a><strong>加密：</strong></h3><h4 id="C语言："><a href="#C语言：" class="headerlink" title="C语言："></a><strong>C语言：</strong></h4><pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;openssl/sha.h&gt;
 
int main()
&#123;
  int i;
  unsigned char result[SHA_DIGEST_LENGTH];
  const char *string = &quot;Encryption Code&quot;;
  SHA1(string, strlen(string), result);
  for(i = 0; i &lt; SHA_DIGEST_LENGTH; i++)
    printf(&quot;%02x%c&quot;, result[i], i &lt; (SHA_DIGEST_LENGTH-1) ? &#39; &#39; : &#39;\n&#39;);
  return EXIT_SUCCESS;
&#125;
</code></pre>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java:"></a>Java:</h4><pre><code>import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
 
public class Digester &#123;
 
    public static void main(String[] args) &#123;
        System.out.println(hexDigest(&quot;Encryption code&quot;, &quot;SHA-1&quot;));
    &#125;
    static String hexDigest(String str, String digestName) &#123;
        try &#123;
            MessageDigest md = MessageDigest.getInstance(digestName);
            byte[] digest = md.digest(str.getBytes(StandardCharsets.UTF_8));
            char[] hex = new char[digest.length * 2];
            for (int i = 0; i &lt; digest.length; i++) &#123;
                hex[2 * i] = &quot;0123456789abcdef&quot;.charAt((digest[i] &amp; 0xf0) &gt;&gt; 4);
                hex[2 * i + 1] = &quot;0123456789abcdef&quot;.charAt(digest[i] &amp; 0x0f);
            &#125;
            return new String(hex);
        &#125; catch (NoSuchAlgorithmException e) &#123;
            throw new IllegalStateException(e);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code>    public static String sha1(String data) throws NoSuchAlgorithmException &#123;
        data += &quot;lyz&quot;;
        MessageDigest md = MessageDigest.getInstance(&quot;SHA1&quot;);
       byte[] b = data.getBytes();
       md.update(b);
        //获取密文  （完成摘要计算）
        byte[] b2 = md.digest();
        //获取计算的长度
        int len = b2.length;
        //16进制字符串
        String str = &quot;0123456789abcdef&quot;;
        //把字符串转为字符串数组
        char[] ch = str.toCharArray();
        //创建一个40位长度的字节数组
        char[] chs = new char[len*2];
        //循环20次
        for(int i=0,k=0;i&lt;len;i++) &#123;
            byte b3 = b2[i];//获取摘要计算后的字节数组中的每个字节
            // &gt;&gt;&gt;:无符号右移  
            // &amp;:按位与
            //0xf:0-15的数字
            chs[k++] = ch[b3 &gt;&gt;&gt; 4 &amp; 0xf];
            chs[k++] = ch[b3 &amp; 0xf];
        &#125;
        //字符数组转为字符串
        return new String(chs);
    &#125;
主函数：
    public static void main(String[] args) throws NoSuchAlgorithmException &#123;
        
        String data = &quot;跳梁小豆tlxd666&quot;;
        String result = sha1(data);
        System.out.println(&quot;加密后：&quot;+result);
&#125;  
</code></pre>
<h4 id="python"><a href="#python" class="headerlink" title="python:"></a>python:</h4><pre><code>import hashlib
h = hashlib.sha1()
h.update(bytes(&quot;Ars longa, vita brevis&quot;, encoding=&quot;ASCII&quot;))
h.hexdigest()
# &quot;e640d285242886eb96ab80cbf858389b3df52f43&quot;
</code></pre>
<h3 id="解密：暴力破解"><a href="#解密：暴力破解" class="headerlink" title="解密：暴力破解"></a><strong>解密：暴力破解</strong></h3><pre><code>package sha1;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.concurrent.Callable;
import java.lang.Math;

public  class Sha1 implements Callable &#123;

    private int threadNumber;
    Sha1(int threadNumber)&#123;
        this.threadNumber = threadNumber ;
    &#125;
    @Override
    public Object call() throws Exception &#123;
        /*可能的字符*/
        char [] encryptedText = (&quot;QWINqwin%(*=2468&quot;).toCharArray();
        //char [] encryptedText = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890~!@#$%^&amp;*()[]|;&#39;,&lt;&gt;.?&quot;.toCharArray();
        /*长度为5的密文字符串*/
        String data = null;
        /*根据输入的线程编号threadNumber，分配相应的任务*/
        int [] temp = new int[8];
        for (int i = 0; i&lt;temp.length ; i++) &#123;
            int n = (int) Math.pow(2,i);
            if((threadNumber &amp; n) &gt; 0)&#123;
                temp[i] = 1;
            &#125;
            else &#123;
                temp[i] = 0;
            &#125;
        &#125;
        int length = encryptedText.length / 2;
        /*8个字符的组合*/
        for(int a = (length * temp[0]) ; a &lt; (length * (temp[0]+1)); a++)&#123;
            for(int b = (length * temp[1]); b &lt; (length * (temp[1]+1)); b++)&#123;
                for(int c = (length * temp[2]); c &lt; (length * (temp[2]+1)); c++)&#123;
                    for(int d = (length * temp[3]); d &lt; (length * (temp[3]+1)); d++)&#123;
                        for(int e = (length * temp[4]); e &lt; (length * (temp[4]+1)); e++)&#123;
                            for(int f = (length * temp[5]); f &lt; (length * (temp[5]+1)); f++)&#123;
                                for(int g = (length * temp[6]); g &lt; (length * (temp[6]+1)); g++)&#123;
                                    for(int h = (length * temp[7]); h &lt; (length * (temp[7]+1)); h++)&#123;
                                        /*获取不同的键盘字符组合*/
                                        data = &quot;&quot;+ encryptedText[a] + encryptedText[b] + encryptedText[c] + encryptedText[d] + encryptedText[e] + encryptedText[f]+ encryptedText[g]+ encryptedText[h];
                                        /*将字符加密*/
                                        String result = sha1(data);
                                        String decrypted = &quot;67ae1a64661ac8b4494666f58c4822408dd0a3e4&quot;;
                                        //String decrypted = &quot;4b58475789e60dbf1a28d638b556a938134644c8&quot;;
                                        /*如果字符加密后的sha1哈希值和所给的相等，即为找到了答案*/
                                        if(decrypted.equals(result))&#123;
                                            //System.out.println(&quot;4b58475789e60dbf1a28d638b556a938134644c8的sha1算法解密结果为： &quot;+data);
                                            System.out.println(&quot;67ae1a64661ac8b4494666f58c4822408dd0a3e4的sha1算法解密结果为： &quot;+data);
                                            return 10;
                                        &#125;
                                    &#125;
                                &#125;
                            &#125;
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
        return 0;
    &#125;
    
    public static String sha1(String data) throws NoSuchAlgorithmException &#123;
        //信息摘要器                                算法名称
        MessageDigest md = MessageDigest.getInstance(&quot;SHA1&quot;);
        //把字符串转为字节数组
        byte[] b = data.getBytes();
        //使用指定的字节来更新我们的摘要
        md.update(b);
        //获取密文  （完成摘要计算）
        byte[] b2 = md.digest();
        //获取计算的长度
        int len = b2.length;
        //16进制字符串
        String str = &quot;0123456789abcdef&quot;;
        //把字符串转为字符串数组
        char[] ch = str.toCharArray();

        //创建一个40位长度的字节数组
        char[] chs = new char[len*2];
        //循环20次
        for(int i=0,k=0;i&lt;len;i++) &#123;
            //获取摘要计算后的字节数组中的每个字节
            byte b3 = b2[i];
            // &gt;&gt;&gt;:无符号右移
            // &amp;:按位与
            //0xf:0-15的数字
            chs[k++] = ch[b3 &gt;&gt;&gt; 4 &amp; 0xf];
            chs[k++] = ch[b3 &amp; 0xf];
        &#125;
        //字符数组转为字符串
        return new String(chs);
    &#125;
&#125;
</code></pre>
<h4 id="SHA加密和解密算法详解-amp-代码示例："><a href="#SHA加密和解密算法详解-amp-代码示例：" class="headerlink" title="SHA加密和解密算法详解&amp;代码示例："></a>SHA加密和解密算法详解&amp;代码示例：</h4><pre><code>import java.security.MessageDigest;
public class SHAUtil &#123;
    /***
     * SHA加密 生成40位SHA码
     */
    public static String shaEncode(String data) throws Exception &#123;
        MessageDigest sha = MessageDigest.getInstance(&quot;SHA&quot;);

        byte[] byteArray = data.getBytes(&quot;UTF-8&quot;);

        // md5Bytes的长度为20
        byte[] md5Bytes = sha.digest(byteArray);

        // 转换成16进制字符串
        StringBuffer hexValue = new StringBuffer();
        for (int i = 0; i &lt; md5Bytes.length; i++) &#123;
            int val = ((int) md5Bytes[i]) &amp; 0xff;
            if (val &lt; 16) &#123;
                hexValue.append(&quot;0&quot;);
            &#125;
            hexValue.append(Integer.toHexString(val));
        &#125;
        return hexValue.toString();
    &#125;

    public static void main(String args[]) throws Exception &#123;
        String str = new String(&quot;1A2B3C4D5E&quot;);
        System.out.println(&quot;原始：&quot; + str);
        System.out.println(&quot;SHA后：&quot; + shaEncode(str));
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>加密与解密</category>
      </categories>
      <tags>
        <tag>散列算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/07/22/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>


<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>《深入理解LTE-A》学习笔记（一）</title>
    <url>/2023/08/28/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3LTE-A%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%20/</url>
    <content><![CDATA[<h1 id="《深入理解LTE-A》学习笔记（一）"><a href="#《深入理解LTE-A》学习笔记（一）" class="headerlink" title="《深入理解LTE-A》学习笔记（一）"></a>《深入理解LTE-A》学习笔记（一）</h1><span id="more"></span>
<p><img src="https://s2.loli.net/2023/08/29/Jzwd1DZ3fq4nuPT.png" alt="image-20230728184032279"></p>
<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><table>
<thead>
<tr>
<th align="left">名称</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>eNode(Evolved Node B)</strong></td>
<td>一个基站，负责无线信号的传输和接收，用于连接移动设备和核心网络。</td>
</tr>
<tr>
<td align="left"><strong>UE</strong></td>
<td>移动终端，由移动设备（ME）和通用用户识别模块（USIM）组成。</td>
</tr>
<tr>
<td align="left"><strong>PCI</strong></td>
<td>物理小区标识</td>
</tr>
<tr>
<td align="left"><strong>PSS/SSS</strong></td>
<td>小区同步信号</td>
</tr>
<tr>
<td align="left"><strong>MIB/SIB</strong></td>
<td>小区相关的系统信息</td>
</tr>
<tr>
<td align="left"><strong>RA Preamble</strong></td>
<td>随机前导码，UE发给eNode，告诉eNode有个接入请求。</td>
</tr>
<tr>
<td align="left"><strong>PDSCH</strong></td>
<td>物理下行共享信道</td>
</tr>
<tr>
<td align="left"><strong>PDCCH</strong></td>
<td>物理下行控制信道，传输上下行的资源调度信息</td>
</tr>
<tr>
<td align="left"><strong>PUSCH</strong></td>
<td>物理上行共享信道</td>
</tr>
<tr>
<td align="left"><strong>PUCCH</strong></td>
<td>物理上行控制信道，传输ACK/NACK，调度请求，信道质量指示等信息。</td>
</tr>
<tr>
<td align="left"><strong>CSI</strong></td>
<td>信道状态信息，UE上传给基站的。</td>
</tr>
<tr>
<td align="left"><strong>Paging</strong></td>
<td>呼叫请求，由eNode发起。</td>
</tr>
<tr>
<td align="left"><strong>msg3</strong></td>
<td>包含UE的随机接入标识符（RAI）和初始接入参数，用于告知基站UE的身份和请求建立连接。</td>
</tr>
<tr>
<td align="left"><strong>SRS</strong></td>
<td>在无线通信中，用于估计上行信道频域信息，做频率选择性调度；用于估计下行信道，做下行波束赋形。</td>
</tr>
<tr>
<td align="left"><strong>SR</strong></td>
<td>上行调度请求</td>
</tr>
<tr>
<td align="left"><strong>BSR</strong></td>
<td>缓冲状态报告，基站接收BSR并为UE分配资源</td>
</tr>
<tr>
<td align="left"><strong>PHICH</strong></td>
<td>物理混合自动重传指示信道。</td>
</tr>
<tr>
<td align="left"><strong>RLC PDU</strong></td>
<td>RLC层协议数据单元</td>
</tr>
<tr>
<td align="left"><strong>RLC SDU</strong></td>
<td>将接收到的RLC PDU重组并排序</td>
</tr>
<tr>
<td align="left"><strong>MAC SDU</strong></td>
<td>服务数据单元，RLC PDU在MAC层被称作MAC SDU</td>
</tr>
<tr>
<td align="left"><strong>MAC PDU</strong></td>
<td>若干个MAC SDU串联在一起，加上MAC子头封装成MAC PDU</td>
</tr>
<tr>
<td align="left"><strong>HARQ</strong></td>
<td>混合式自动重传请求</td>
</tr>
<tr>
<td align="left"><strong>SRB</strong></td>
<td>信令无线承载，在控制平面，RLC 承载上层的业务称之为信令无线承载，为RRC 层传递信令</td>
</tr>
<tr>
<td align="left"><strong>CCCH</strong></td>
<td>公共控制信道，是一种“一点对多点”的双向控制信道，在呼叫接续阶段，传输链路连接所需要的控制信令与信息。</td>
</tr>
<tr>
<td align="left"><strong>PCCH</strong></td>
<td>物理控制信道，用于发送寻呼消息，网络到用户的下行信道</td>
</tr>
<tr>
<td align="left"><strong>BCCH</strong></td>
<td>广播控制信道，在实际工作之前，协调、控制、管理用户行为。</td>
</tr>
<tr>
<td align="left"><strong>DCCH</strong></td>
<td>专用控制信道，点对点的双向控制信道，在呼叫接续阶段和在通信进行当中，在基站和移动台之间传输必要的控制信息。</td>
</tr>
<tr>
<td align="left"><strong>DTCH</strong></td>
<td>专用业务信道，UE和网络之间点对点和上下行双向业务数据传送渠道。</td>
</tr>
<tr>
<td align="left"><strong>MCCH</strong></td>
<td>多播控制信道，点对多点的从网络侧到UE的MBMS控制信息的传送通道，包括正在进行通信或即将要进行通信的MBMS会话信息。</td>
</tr>
<tr>
<td align="left"><strong>MTCH</strong></td>
<td>多播业务信道，用于承载MBMS业务数据。</td>
</tr>
<tr>
<td align="left"><strong>MBMS</strong></td>
<td>多媒体广播组播业务</td>
</tr>
<tr>
<td align="left"><strong>EPC</strong></td>
<td>4G核心网络</td>
</tr>
<tr>
<td align="left"><strong>S-GW</strong></td>
<td>服务网关，终止于E-UTRAN接口的网关。</td>
</tr>
<tr>
<td align="left"><strong>P-GW</strong></td>
<td>分组数据网关，面向PDN终结于SGi接口的网关。</td>
</tr>
<tr>
<td align="left"><strong>S5/S8 bearer</strong></td>
<td>S-GW和P-GW间的传输承载。</td>
</tr>
<tr>
<td align="left"><strong>RDB</strong></td>
<td>Radio Bearer，是指UE与基站(eNB)间的传输承载。</td>
</tr>
<tr>
<td align="left"><strong>S1 Bearer</strong></td>
<td>指eNB与服务网关(Serving Gateway，S-GW)间对于特定UE的承载。</td>
</tr>
<tr>
<td align="left">。。。</td>
<td></td>
</tr>
</tbody></table>
<h1 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h1><h2 id="一、空口传输"><a href="#一、空口传输" class="headerlink" title="一、空口传输"></a>一、空口传输</h2><h3 id="1、下行传输"><a href="#1、下行传输" class="headerlink" title="1、下行传输"></a>1、下行传输</h3><p>由nNode发送，UE负责接收的传输。</p>
<p><img src="https://s2.loli.net/2023/08/29/23nu9FifLExajmY.png" alt="image-20230823202111190"></p>
<p>下行相关流程：</p>
<p>1、UE在进入基站前，会选择一个运营商，即PLMN。</p>
<p>2、eNode每隔5ms会发送一次同步信号PSS/SSS。UE通过PSS/SSS，来选择eNode并获得时间与频率上的同步（并没有上行时间的同步），以及eNode的PCI（物理标识）。</p>
<p>3、小区会不停发送与小区相关的系统信息（MIB/SIB），UE在需要的时候获取这些信息。</p>
<p>4、UE获得信息后，会发起随机接入过程与小区建立连接（RA Preamble），同时产生反馈信息（RAR）。</p>
<p>5、建立连接完成，可以进行数据传输。eNode通过PDSCH信道来给UE传输数据，同时通过PDCCH告诉UE对应的PDSCH在哪些无限资源上传输以及如何传输。UE使用ACK/NACK信号告诉基站是否接收成功（通过PUCCH和PUSCH信道发送），基站没有接收则会重传。</p>
<p>6、信道条件动态变化，UE将下行无线信道条件通过CSI反馈给基站，使基站在下行调度时将信道质量考虑在内。</p>
<p>7、当双方没有数据传输时，UE不需要一直保持连接状态（RRC_CONNECTED）。UE可以处于RRC_IDLE状态，定期唤醒去接收paging信息，确定是否有呼叫请求。</p>
<h3 id="2、上行传输"><a href="#2、上行传输" class="headerlink" title="2、上行传输"></a>2、上行传输</h3><p>由UE发送，nNode负责接收的传输。</p>
<p><img src="https://s2.loli.net/2023/08/29/C9sxXoSmfqu6Uec.png" alt="image-20230827130438050"></p>
<p>上行相关流程：</p>
<p>1、随机接入过程中，UE会发送Preamble和Msg3以便和基站建立连接。</p>
<p>2、基站在上行调度时，需要进行上行信道估计，通过UE发送的SRS进行测量得到。</p>
<p>3、eNode通过PDCCH给UE发送UL grant（物理控制信息）时，UE才能够使用对应的资源进行上行传输。当UE没有被分配上行PUSCH资源但有上行数据需要发送时，UE会发送SR告诉eNode，并请求eNode分配上行PUSCH资源。</p>
<p>4、发送了调度请求后，UE发送了BSR告诉基站有多少数据要发送。</p>
<p>5、UE通过PUSCH给eNode发送数据，同时eNode发送确认信号ACK/NACK（通过PHICH信道发送）给UE。UE没有接收到确认信号则会重传。</p>
<p>6、信道条件动态变化，UE将下行无线信道条件通过CSI反馈给基站（通过PUCCH或PUSCH传输）。</p>
<h2 id="二、LTE协议栈结构"><a href="#二、LTE协议栈结构" class="headerlink" title="二、LTE协议栈结构"></a>二、LTE协议栈结构</h2><p>主要说明基站和UE如何进行用户面和控制面的数据传输。</p>
<p><strong>下行无线协议框架：</strong></p>
<p><img src="https://s2.loli.net/2023/08/29/P8zlhmxgEtAwrY9.png" alt="image-20230827134709982"></p>
<p><strong>上行无线协议框架：</strong></p>
<p><img src="https://s2.loli.net/2023/08/29/xdiS6FnmguZNOQc.png" alt="image-20230827134759898"></p>
<h3 id="1、用户面协议"><a href="#1、用户面协议" class="headerlink" title="1、用户面协议"></a>1、用户面协议</h3><p><img src="https://s2.loli.net/2023/08/29/RwOEjsCd6pPnqyU.png" alt="image-20230827135801461"></p>
<p>1、PDCP层（分组数据汇聚协议层）：针对来自控制面的RRC和来自数据面的IP包进行处理，主要实现加密和完整性保护。</p>
<ul>
<li>头部压缩和解压缩：使用ROHC，应用于用户面数据</li>
<li>加解密：用于用户面和控制面数据</li>
<li>完整性保护：用于控制面数据</li>
<li>传输用户数据和控制面数据</li>
<li>切换时重排序和重传处理</li>
<li>由于超时而丢弃用户面数据</li>
</ul>
<p>2、RLC层（无线链路控制层）：主要实现无线链路控制功能ARQ纠错。<strong>以无线承载的方式为PDCP层提供服务</strong></p>
<p>三种模式：</p>
<ol>
<li>TM透明模式</li>
<li>UM重发非确认模式</li>
<li>AM重发确认模式</li>
</ol>
<ul>
<li><strong>分段串联和重组RLC SDU</strong>：适用于UM和AM。由于RLC PDU的大小由MAC决定，大小并不等于RLC SDU的大小，因此在发送端需要分段/串联RLC SDU以便适合MAC层指定的大小，接收端需要将分组的RLC SDU重组，以便恢复出原来的RLC SDU并发往上层。</li>
<li><strong>ARQ纠错（适用于AM）</strong>：重传机制。MAC层的HARQ机制实现快速重传，反馈出错率约1%，不适用于要求过高的业务。RLC重传处理能够降低反馈出错率。</li>
<li><strong>对RLC PDU重排序</strong>：MAC层的HARQ可能导致到达RLC层的报文路乱序，需要RLC层进行重排序。</li>
<li><strong>重复包检测</strong>：适用于 UM 和 AM 模式。出现重复包的最大可能性为发送端反馈了HARQ ACK，但接收端错误地将其解释NACK，从而导致了不必要的MAC PDU 重传。</li>
<li><strong>对RLC PDU进行重分段</strong>：适用于AM模式。当RLC PDU数据需要重传时，也可能需要重分段（要求大小不一致时）。</li>
</ul>
<p>3、MAC层（媒体接入层）：以逻辑信道的方式为RLC层提供服务，为RLC层业务与物理层之间提供一个有效的连接。</p>
<ul>
<li><strong>匹配逻辑信道和传输信道。</strong></li>
<li><strong>复用/解复用</strong>：将属于一个或不同的逻辑信道的多个MAC SDU复用到同一个MAC PDU上，发给物理层。</li>
<li><strong>通过HARQ来纠错</strong>：重传机制。</li>
<li><strong>调度处理</strong></li>
<li><strong>逻辑信道优先级处理</strong>：从不同的等待队列选出一个分组，将其传递到物理层，并通过无线接口发送的过程。</li>
<li><strong>调度信息上报</strong></li>
<li><strong>随机接入过程处理</strong></li>
</ul>
<h4 id="UE与核心网进行用户面的数据通信过程"><a href="#UE与核心网进行用户面的数据通信过程" class="headerlink" title="UE与核心网进行用户面的数据通信过程"></a>UE与核心网进行用户面的数据通信过程</h4><p>核心网（EPC）通过外部承载与因特网建立连接，并通过EPS bearer 与UE建立连接。即核心网和UE之间的数据通信是承载在EPS bearer上的。</p>
<p><img src="https://s2.loli.net/2023/08/29/6bikx7vGXKwzPJd.png" alt="image-20230827233230528"></p>
<p>一个EPS bearer跨越多个接口：</p>
<ul>
<li>P-GW和S-GW之间的S5/S8接口。</li>
<li>S-GW 和 eNodeB 之间的 S1 接口。</li>
<li>eNodeB 和 UE 之间的无线接口。</li>
</ul>
<p>一个 EPS bearer 由一个 S5/S8 bearer 和一个 E-RAB 组成。一个 E-RAB 由一个 S1 bearer 和一个DRB 组成。</p>
<ul>
<li> 一个 E-RAB 在 UE 和 EPC 之间传输一个 EPS bearer 的数据。如果存在一个 E-RAB，则该 E-RAB 与一个 EPS bearer 存在一一映射关系。</li>
<li>个 DRB 在 UE 和 eNodeB 之间（Uu 接口）传输一个 EPS bearer 的数据。如果存在一个 DRB，则该 DRB 与一个 EPS bearer/E-RAB 存在一一映射关系。</li>
<li>一个 S1 bearer 在 eNodeB 和 S-GW 之间（S1 接口）传输一个 EPS bearer 的数据。</li>
<li>一个 S5/S8 bearer 在 S-GW 和 P-GW 之间（S5/S8 接口）传输一个 EPS bearer 的数据。</li>
</ul>
<p><strong>S-GW</strong>：</p>
<ul>
<li>进行eNodeB间切换时，可以作为本地锚定点，并协助完成eNodeB的重排序功能；</li>
<li>在3GPP不同接入系统间切换时，作为移动性锚点（终结在S4接口，在2G/3G系统和P-GW间实现业务路由），同样具有重排序功能；</li>
<li>执行合法侦听功能；</li>
<li>进行数据包的路由和前转；</li>
<li>在上行和下行传输层进行分组标记；</li>
<li>空闲状态下，下行分组缓冲和发起网络触发的服务请求功能；</li>
<li>用于运营商间的计费</li>
</ul>
<h3 id="2、控制面协议"><a href="#2、控制面协议" class="headerlink" title="2、控制面协议"></a>2、控制面协议</h3><p><img src="https://s2.loli.net/2023/08/29/pOal51gvh6zo2xF.png" alt="image-20230827205208886"></p>
<p>1、RRC层（无线资源控制层）：完成广播、寻呼、RRC连接管理、资源控制、移动性管理、UE测量报告与控制。</p>
<ul>
<li>广播系统消息</li>
<li>RRC连接控制</li>
<li>Inter-RAT 移动性管理</li>
<li>测量配置和上报</li>
<li>发动专用的NAS消息</li>
<li>传输UE接入能力信息</li>
</ul>
<p>RRC和NAS消息使用SRB来传输，LTE中定义了三种SRB：SRB0、SRB1、SRB2。</p>
<p><strong>SRB（信令无线承载）</strong>：</p>
<p>SRB0是默认的无线承载，使用SRB0的RRC消息都使用CCCH来传输，SRB0并没有一个对应的PDCP实体，在PDCP层是透明传输，既没有完整性保护，也没有加解密处理。</p>
<p>SRB1用于发送RRC消息，并在SRB2发送之前，用于发送NAS消息，都使用DCCH发送。</p>
<p>SRB2用于发送包含记录的测量信息在内的RRC消息，并发送SRB消息，都使用DCCH发送。</p>
<p>除SRB0，每个RB都有一个PDCP实体（完整性保护和加解密），每个PDCP实体都有1个或2个RLC实体，取决于RB的属性和RLC模式。</p>
<h3 id="下行峰值速率计算"><a href="#下行峰值速率计算" class="headerlink" title="下行峰值速率计算"></a>下行峰值速率计算</h3><p>满足以下条件的最大吞吐量：</p>
<ol>
<li>整个带宽均分配给一个UE。</li>
<li>使用最高阶的MCS。</li>
<li>使用可支持的最大天线数。</li>
</ol>
<p>参考文章：</p>
<p><a href="https://blog.51cto.com/u_16099211/6506095">https://blog.51cto.com/u_16099211/6506095</a></p>
<p><a href="https://blog.csdn.net/qq_40232834/article/details/131807104">https://blog.csdn.net/qq_40232834/article/details/131807104</a></p>
]]></content>
  </entry>
  <entry>
    <title>初识Frida框架</title>
    <url>/2021/09/09/%E5%88%9D%E8%AF%86Frida%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="初识Frida框架"><a href="#初识Frida框架" class="headerlink" title="初识Frida框架"></a>初识Frida框架</h2><span id="more"></span>

<p>Frida是一款基于Python + JavaScript 的hook框架，本质是一种动态插桩技术。可以用于Android、Windows、iOS等各大平台，其执行脚本基于Python或者Node.js写成，而注入代码用JavaScript写成。相比于Xposed更加便捷，环境安装简单，使用方便。</p>
<h3 id="Frida安装"><a href="#Frida安装" class="headerlink" title="Frida安装"></a>Frida安装</h3><p>1、安装Python（这里不做介绍）。</p>
<p>2、安装frida、frida-tools(两个版本必须一致，我这里都为15.1.2)</p>
<pre><code>pip install pipfrida 
pip install frida-tools
</code></pre>
<p>安装之后可以检查版本是否一致。</p>
<p><img src="https://s2.loli.net/2022/01/21/sZ46KVfCmnMktuj.png" alt="QQ截图20211011210105.png"></p>
<p>2、连接模拟器，安装frida-server。</p>
<p><a href="https://github.com/frida/frida/releases">frida-server下载链接</a>，找到对应的版本，手机是arm64，模拟器是x86，下载之后解压，将文件改名为fs。</p>
<p>连接模拟器，adb devices 显示不到打开的模拟器时手动连接。如下：</p>
<pre><code>夜神模拟器：adb connect 127.0.0.1:62001
逍遥安卓模拟器：adb connect 127.0.0.1:21503
天天模拟器：adb connect 127.0.0.1:6555
海马玩模拟器：adb connect 127.0.0.1:53001
网易MUMU模拟器：adb connect 127.0.0.1:7555 MacOS:adb connect 127.0.0.1:5555
genymotion模拟器：adb connect 127.0.0.1:5555
谷歌原生模拟器：adb connect &lt;设备的IP地址&gt;：5555
</code></pre>
<p>连接之后进行如下操作：</p>
<pre><code>1、adb push fs文件所在地址/fa /data/local/tmp
2、adb shell
3、su
4、cd /data/local/tmp
5、chmod 777 fs
6、./fs
(如果此时光标在下一行闪，说明frida运行成功)
</code></pre>
<p><img src="https://s2.loli.net/2022/01/21/IVaptHr3NfkxTZj.png" alt="QQ截图20211011212732.png"></p>
<p>3、、验证是否安装成功</p>
<p>不要关闭此页面，另外打开一个cmd窗口，执行以下指令：frida-ps -U，如果该模拟器中运行的所有进程都显示出来，说明frida安装成功。</p>
<h3 id="Frida初体验"><a href="#Frida初体验" class="headerlink" title="Frida初体验"></a>Frida初体验</h3><p>frida框架最大的优势就是操作简单，相比于Xposed来说不需要另生成一个项目来运行，只需要编写一个插件直接再命令框执行即可。Frida的编写可以用js、python、js+python三种方法来写。初学者建议使用js+python方式来写，只需要编写相应的js代码，python文件基本固定。</p>
<p>在使用插件进行hook时，首先应该转发端口。具体操作如下：</p>
<p><img src="https://s2.loli.net/2022/01/21/cQ2DnkFjBvYu9ao.png" alt="QQ截图20211011214700.png"></p>
<p>脚本样例：</p>
<pre><code>import frida
import sys

def on_message(message,data): 
    print(message)

jscode = &quot;&quot;&quot;
Java.perform(function()&#123;
    var MainActivity=Java.use(&#39;com.example.frida_new1.MainActivity&#39;);
    MainActivity.getCale.implementation=function()&#123;
        send(&#39;Hook start....&#39;);
        return &#39;hook成功!!!&#39;
    &#125;
   &#125;);
&quot;&quot;&quot;
process = frida.get_remote_device().attach(&#39;Frida_new1&#39;)//这里踩了很多坑，attach里面抓包并不是完整包名，而是文件名
script = process.create_script(jscode)
script.on(&#39;message&#39;, on_message)
script.load()
sys.stdin.read()
</code></pre>
<p>这里有两种方法运行该插件：</p>
<p>1、打开python所在的目录，打开cmd页面执行</p>
<pre><code>python test.py
</code></pre>
<p>2、在NotePad++等高级记事本中，直接运行。建议将如下命令保存以便后面可以直接使用该文件运行。</p>
<pre><code>cmd /k python &quot;D:\Desktop\test.py&quot; &amp; ECHO &amp; PAUSE &amp; EXIT//双引号中表示脚本的路径
</code></pre>
<p>运行之后点击按钮(这里hook 的是Button事件的显示方法)</p>
<p><img src="https://s2.loli.net/2022/01/21/v8ab6grsUD7IqiO.png" alt="QQ截图20211011214839.png"></p>
<p>Hook 成功。</p>
]]></content>
      <categories>
        <category>Frida框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Frida框架</tag>
        <tag>hook</tag>
      </tags>
  </entry>
  <entry>
    <title>初识Xposed框架</title>
    <url>/2021/08/15/%E5%88%9D%E8%AF%86Xposed%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>Xposed</strong>（也被称作Xposed框架、XP框架、Xposed framework），是一个运行于Android操作系统的hook框架。其通过替换Android系统的关键文件，可以拦截几乎所有Java函数的调用，并允许通过Xposed模块中的自定义代码更改调用这些函数时的行为。因此，Xposed常被用来<strong>修改Android系统和应用程序的功能。</strong></p>
<span id="more"></span>
<p>简单来说，它允许你在不修改apk源码的情况下，通过编写自己的模块来改变apk的行为。采用了插件机制，模块能够适用不同版本的框架和rom。模块改变apk行为的操作发生在内存中，对源apk不进行任何修改。你只需要安装编写的模块并重启相应的设备即可。</p>
<h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><p>xposed 主要由三个项目来组成的：</p>
<ol>
<li>Xposed的C++ 部分，主要是用来替换 /system/bin/app_process，并为XposedBridge 提供 JNI方法。</li>
<li>XposedBridge：Xposed 提供的jar文件，app_process 启动过程中会加载该jar包，其他的 Modules 的开发都是基于 该jar包。</li>
<li>XposedInstaller：Xposed的安装包，提供对基于Xposed框架的Modules的管理。</li>
</ol>
<p>xposed 目前已逐步支持 ART虚拟机，兼容 android 5.0 以上版本。</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>Xposed框架是以模块扩展方式来实现对系统部分功能的修改，这些模块都依赖于Xposed框架。用户可以在一些应用商店或其自带的下载库进行下载安装。在中国大陆，还有精简QQ，个性化微信界面等用途的模块。</p>
<h3 id="目前存在的问题"><a href="#目前存在的问题" class="headerlink" title="目前存在的问题"></a>目前存在的问题</h3><p>部分专有软件（如微信、支付宝等）会检测Xposed框架的存在，并强迫用户卸载Xposed框架及相关组件，否则用户将无法继续使用其所提供的服务。但是这些问题可以使用相应的模块来解决，比如Xposed黑名单模块。</p>
]]></content>
      <categories>
        <category>Xposed框架</category>
      </categories>
      <tags>
        <tag>Xposed框架</tag>
      </tags>
  </entry>
  <entry>
    <title>编写Xposed框架初体验</title>
    <url>/2021/08/31/%E7%BC%96%E5%86%99Xposed%E6%A1%86%E6%9E%B6%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<h4 id="具体步骤："><a href="#具体步骤：" class="headerlink" title="具体步骤："></a>具体步骤：</h4><span id="more"></span>
<ol>
<li>修改配置文件，添加xposed插件相关数据。在AndroidManifest.xml中添加以下代码：</li>
</ol>
<pre><code class="java">        &lt;!--添加标识--&gt;
        &lt;meta-data
            android:name=&quot;xposedmodule&quot;
            android:value=&quot;true&quot;/&gt;
        &lt;!--载入HOOK模块之后显示的信息--&gt;
        &lt;meta-data
            android:name=&quot;xposeddescription&quot;
            android:value=&quot;Xposed框架初体验&quot;/&gt;
        &lt;!--规定jar包的版本信息--&gt;
        &lt;meta-data
            android:name=&quot;xposedminversion&quot;
            android:value=&quot;54&quot;/&gt;
</code></pre>
<p>2、新建lib文件夹，将Xposed框架提供的jar包放到此文件夹中。具体流程：右击app-&gt;new-&gt;Directory-&gt;输入lib-&gt;将jar包复制到此文件夹中-&gt;右击文件夹-&gt;Add as Library-&gt;在build.gradle中将implementation改为compileOnly files。</p>
<p>3、新建一个类Xposedhook实现IXposedHookLoadPackage接口。</p>
<pre><code class="java">import android.util.Log;
import de.robv.android.xposed.IXposedHookLoadPackage;
import de.robv.android.xposed.XposedBridge;
import de.robv.android.xposed.callbacks.XC_LoadPackage;
public class Xposedhook implements IXposedHookLoadPackage &#123;
    //Xposed插件入口点
    @Override
    public void handleLoadPackage(XC_LoadPackage.LoadPackageParam Param) throws Throwable &#123;
        XposedBridge.log(&quot;cly hook start-------&gt;当前启动的程序是：&quot;+Param.processName);

        Log.d(&quot;L61q4_Cheng&quot;, &quot;hook Start......&quot;);
    &#125;
&#125;
</code></pre>
<p>4、在Main/assets中新建一个文本文件xposed_init,并在其中添加新建的类，包名加类名，</p>
<blockquote>
<p>com.example.xposed_new3.Xposedhook</p>
</blockquote>
<p><img src="https://i.loli.net/2021/09/02/V7Ed16pDAlcXawL.png" alt="QQ截图20210831173424.png"></p>
<p>5、编译成apk并运行，在xposed Installer中查看日志。</p>
<p><img src="https://i.loli.net/2021/09/02/L2JmEZDSCeIMGAT.png" alt="QQ截图20210831174541.png"></p>
]]></content>
      <categories>
        <category>Xposed框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>对称算法（DES篇）</title>
    <url>/2021/07/22/%E5%AF%B9%E7%A7%B0%E7%AE%97%E6%B3%95%EF%BC%88DES%E7%AF%87%EF%BC%89/</url>
    <content><![CDATA[<p><strong>DES</strong> (Data Encryption Standard)算法是世界上最常用的加密算法。在很长时间内，许多人心目中“密码生成”与DES一直是个同义词。尽管最近有个叫Electronic Frontier Foundation的组织造了台价值22万的机器尝试破解DES加密的数据，DES和它的变种“三重数据加密算法”仍将在政府和银行中广泛应用。</p>
<span id="more"></span>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h2><p>DES全称为Data Encryption Standard，即数据加密标准。1997年数据加密标准DES正式公布，其分组长度为64比特，密钥长度为64比特，其中8比特为奇偶校验位，所以实际长度为56比特。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>数据加密标准，速度较快，适用于加密大量数据的场合。</p>
<h2 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h2><p>DES是一个<strong>分组加密算法</strong>，就是将明文分组进行加密，每次按顺序取明文一部分，一个典型的DES以64位为分组，加密解密用算法相同。它的密钥长度为56位，因为每组第8位是用来做奇偶校验，密钥可以是任意56位的数，保密性依赖于密钥。</p>
<p>利用56+8奇偶校验位（第8,16,24,32,40,48,56,64）=64位的密钥对以64位为单位的块数据进行加解密。</p>
<h2 id="具体加密步骤"><a href="#具体加密步骤" class="headerlink" title="具体加密步骤"></a>具体加密步骤</h2><p><strong>所需参数：</strong></p>
<p>key：8个字节共64位的工作密钥</p>
<p>data：8个字节共64位的需要被加密或被解密的数据</p>
<p>mode：DES工作方式，加密或者解密</p>
<h3 id="1、置换IP：（生成16个子密钥，每个密钥长度为48-bit）"><a href="#1、置换IP：（生成16个子密钥，每个密钥长度为48-bit）" class="headerlink" title="1、置换IP：（生成16个子密钥，每个密钥长度为48 bit）"></a><strong>1、置换IP：（生成16个子密钥，每个密钥长度为48 bit）</strong></h3><p>利用<strong>初始置换</strong>IP(Initial Permutation)对明文X进行换位处理，打乱原来的次序，得到一个乱序的64 bit 明文组。使用64位的密钥key将64位的明文输入块变为64位的密文输出块。</p>
<p>注意：这里的数字表示的是原数据的位置，不是数据</p>
<p>即将X中的58位数据放在转换后生成的X’表的第1位，X中的第50位放在X’的第2位，X中的42位放在第3位…X中的第7位放在X’的最后一位。</p>
<p><strong>置换表如下：（纵向看）</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>58</td>
<td>50</td>
<td>42</td>
<td>34</td>
<td>26</td>
<td>18</td>
<td>10</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>60</td>
<td>52</td>
<td>44</td>
<td>36</td>
<td>28</td>
<td>20</td>
<td>12</td>
<td>4</td>
</tr>
<tr>
<td>2</td>
<td>62</td>
<td>54</td>
<td>46</td>
<td>38</td>
<td>30</td>
<td>22</td>
<td>14</td>
<td>6</td>
</tr>
<tr>
<td>3</td>
<td>64</td>
<td>56</td>
<td>48</td>
<td>40</td>
<td>32</td>
<td>24</td>
<td>16</td>
<td>8</td>
</tr>
<tr>
<td>4</td>
<td>57</td>
<td>49</td>
<td>41</td>
<td>33</td>
<td>25</td>
<td>17</td>
<td>9</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>59</td>
<td>51</td>
<td>43</td>
<td>35</td>
<td>27</td>
<td>19</td>
<td>11</td>
<td>3</td>
</tr>
<tr>
<td>6</td>
<td>61</td>
<td>53</td>
<td>45</td>
<td>37</td>
<td>29</td>
<td>21</td>
<td>13</td>
<td>5</td>
</tr>
<tr>
<td>7</td>
<td>63</td>
<td>55</td>
<td>47</td>
<td>39</td>
<td>31</td>
<td>23</td>
<td>15</td>
<td>7</td>
</tr>
</tbody></table>
<p>代码实现（C语言）：</p>
<pre><code>const unsigned char IP_Table[64] = 
&#123; 58, 50, 42, 34, 26, 18, 10, 2, 60, 52,44, 
  36, 28, 20, 12, 4, 62, 54, 46, 38, 30,22, 
  14, 6, 64, 56, 48, 40, 32, 24, 16, 8,57, 
  49, 41, 33, 25, 17, 9, 1, 59, 51, 43,35, 
  27, 19, 11, 3, 61, 53, 45, 37, 29, 21,13, 
  5, 63, 55, 47, 39, 31, 23, 15, 7 &#125;; 
int IP_Substitution(const unsigned char* BitPlain, unsigned char* Bit_IP_Table)
&#123; 
    int ret = 0; 
    for (int i = 0; i &lt; 64; i++) &#123; 
    Bit_IP_Table[i] = BitPlain[IP_Table[i] - 1]; 
    &#125; 
  return ret; 
&#125; 
</code></pre>
<h3 id="2、分组（L，R组）"><a href="#2、分组（L，R组）" class="headerlink" title="2、分组（L，R组）"></a><strong>2、分组（L，R组）</strong></h3><p>把输出块分为L0、R0两部分，每部分均为32位。0-3为L组，3-7为R组</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>58</td>
<td>50</td>
<td>42</td>
<td>34</td>
<td>26</td>
<td>18</td>
<td>10</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>60</td>
<td>52</td>
<td>44</td>
<td>36</td>
<td>28</td>
<td>20</td>
<td>12</td>
<td>4</td>
</tr>
<tr>
<td>2</td>
<td>62</td>
<td>54</td>
<td>46</td>
<td>38</td>
<td>30</td>
<td>22</td>
<td>14</td>
<td>6</td>
</tr>
<tr>
<td>3</td>
<td>64</td>
<td>56</td>
<td>48</td>
<td>40</td>
<td>32</td>
<td>24</td>
<td>16</td>
<td>8</td>
</tr>
<tr>
<td>4</td>
<td>57</td>
<td>49</td>
<td>41</td>
<td>33</td>
<td>25</td>
<td>17</td>
<td>9</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>59</td>
<td>51</td>
<td>43</td>
<td>35</td>
<td>27</td>
<td>19</td>
<td>11</td>
<td>3</td>
</tr>
<tr>
<td>6</td>
<td>61</td>
<td>53</td>
<td>45</td>
<td>37</td>
<td>29</td>
<td>21</td>
<td>13</td>
<td>5</td>
</tr>
<tr>
<td>7</td>
<td>63</td>
<td>55</td>
<td>47</td>
<td>39</td>
<td>31</td>
<td>23</td>
<td>15</td>
<td>7</td>
</tr>
</tbody></table>
<p>代码实现（C语言）：</p>
<pre><code>unsigned char Bit_IP_Table[64]; //初始置换后的明文表 
unsigned char BitL_Table[17][32]; //L表Bit组 
unsigned char BitR_Table[17][32]; //R表Bit组 

memcpy(BitL_Table[0], Bit_IP_Table, 32); 
memcpy(BitR_Table[0], &amp;Bit_IP_Table[32],32); 
</code></pre>
<h3 id="3、右分组（R组）由32位扩展为48位"><a href="#3、右分组（R组）由32位扩展为48位" class="headerlink" title="3、右分组（R组）由32位扩展为48位"></a><strong>3、右分组（R组）由32位扩展为48位</strong></h3><p>通过扩展置换变对R组进行扩展，原理和前面的置换表差不多，<strong>就是多了一些重复的映射</strong></p>
<p>第0列、5列为拓展数据，1-4列为原始数据，</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>32</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>1</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
</tr>
<tr>
<td>2</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
<td>12</td>
<td>13</td>
</tr>
<tr>
<td>3</td>
<td>12</td>
<td>13</td>
<td>14</td>
<td>15</td>
<td>16</td>
<td>17</td>
</tr>
<tr>
<td>4</td>
<td>16</td>
<td>17</td>
<td>18</td>
<td>19</td>
<td>20</td>
<td>21</td>
</tr>
<tr>
<td>5</td>
<td>20</td>
<td>21</td>
<td>22</td>
<td>23</td>
<td>24</td>
<td>25</td>
</tr>
<tr>
<td>6</td>
<td>24</td>
<td>25</td>
<td>26</td>
<td>27</td>
<td>28</td>
<td>29</td>
</tr>
<tr>
<td>7</td>
<td>28</td>
<td>29</td>
<td>30</td>
<td>31</td>
<td>32</td>
<td>1</td>
</tr>
</tbody></table>
<p>代码实现（C语言）：</p>
<pre><code>const unsigned char E_Table[48] = 
&#123; 32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 
10, 11, 12, 13, 12, 13, 14, 15, 16, 17, 16, 
17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25, 
24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1&#125;; 
int E_Substitution(const unsigned char* BitR_Table, unsigned char* BitE_Table） 
&#123; 
    int ret = 0; 
    for (int i = 0; i &lt; 48; i++) &#123; 
        BitE_Table[i] = BitR_Table[E_Table[i] - 1]; 
    &#125; 
    return ret; 
&#125; 
#### 4.扩展的R组和48位密钥进行异或 
int DES_XOR(const unsigned char* Bit1_Table, const unsigned char* Bit2_Table, unsigned char* Bit_Xor/*异或运算的结果*/, int nBit/*异或运算的位数*/) &#123; 
    int ret = 0; 
    for (int i = 0; i &lt; nBit; i++) &#123; 
        Bit_Xor[i] = Bit1_Table[i] ^ Bit2_Table[i]; 
    &#125; 
    return ret; 
&#125; 
</code></pre>
<h3 id="4、将48位异或的结果转换为32位"><a href="#4、将48位异或的结果转换为32位" class="headerlink" title="4、将48位异或的结果转换为32位"></a><strong>4、将48位异或的结果转换为32位</strong></h3><p>详细过程：</p>
<p>先将48为分成<strong>8组</strong>，每组<strong>6位</strong>，在将6位数字经过变化转换为<strong>4位</strong></p>
<p>**6-&gt;4操作:**例（一个6位的分组）</p>
<p>100101</p>
<p>将该分组的<strong>第一位和最后一位</strong>取出来，以二进制的形式表示，作为<strong>行索引</strong></p>
<p>将该分组的<strong>第2到5位</strong>取出来，以二进制的形式表示，作为<strong>列索引</strong></p>
<p>代码实现（C语言）：</p>
<pre><code>const unsigned char S_Table[8][4][16] = &#123; 
    //S1盒 
    14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7, 
    0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8, 
    4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0, 
    15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13, 
    //S2盒 
    15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10,
    3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5, 
    0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15, 
    13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9, 
    //S3盒 
    10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8, 
    13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1, 
    13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7, 
    1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12, 
    //S4盒 
    7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15, 
    13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9, 
    10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4,
     3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14, 
     //S5盒 
     2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9, 
     14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6, 
     4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14,
      11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3,
     //S6盒 
      12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11, 
      10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8, 
      9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6, 
      4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13, 
      //S7盒 
      4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1, 
      13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6,
      1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2,
      6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12,
      //S8盒 
      13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7, 
      1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2, 
      7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8, 
      2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11 &#125;; 
unsigned char Bit_Xor[8][6]; //存放异或运算的结果 
unsigned char Bit_Integer[8][4]; //将整数变成Bit位 
unsigned char Row; //S盒的行号 unsigned char Col; 
//S盒的列号 
unsigned char Integer; 
//从S盒中取得的32位整数 
for (int i = 0; i &lt; 8; i++) &#123; 
//计算S盒的行号和列号 
    Row = (Bit_Xor[i][0] &lt;&lt; 1) + Bit_Xor[i][5];
     Col = (Bit_Xor[i][1] &lt;&lt; 3) + (Bit_Xor[i][2] &lt;&lt; 2) + (Bit_Xor[i][3] &lt;&lt; 1) + Bit_Xor[i][4]; 
 //从S盒中取得整数 
 Integer = S_Table[i][Row][Col]; 
 //将取得的4Bit数转换成Bit组 
for (int j = 0; j &lt; 4; j++) &#123; 
     Bit_Integer[i][j] = Integer &gt;&gt; (3 - j) &amp; 1; 
 &#125; 
 &#125; 
</code></pre>
<h3 id="5、p置换"><a href="#5、p置换" class="headerlink" title="5、p置换"></a><strong>5、p置换</strong></h3><p>同最开始的初始置换，只是对数据进行了打乱操作</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>16</td>
<td>7</td>
<td>20</td>
<td>21</td>
<td>29</td>
<td>12</td>
<td>28</td>
<td>17</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>15</td>
<td>23</td>
<td>26</td>
<td>5</td>
<td>18</td>
<td>31</td>
<td>10</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>8</td>
<td>24</td>
<td>14</td>
<td>32</td>
<td>27</td>
<td>3</td>
<td>9</td>
</tr>
<tr>
<td>3</td>
<td>19</td>
<td>13</td>
<td>30</td>
<td>6</td>
<td>22</td>
<td>11</td>
<td>4</td>
<td>25</td>
</tr>
</tbody></table>
<p>代码实现（C语言）：</p>
<pre><code>const unsigned char P_Table[32] =
&#123;
    16, 7,  20, 21, 29, 12, 28, 17,
    1,  15, 23, 26, 5,  18, 31, 10,
    2,  8,  24, 14, 32, 27, 3,  9,
    19, 13, 30, 6,  22, 11, 4,  25
&#125;;
int P_Substitution(const unsigned char *Bit_Integer, unsigned char* BitP_Table)
&#123;
    int ret = 0;
    for (int i = 0; i &lt; 32; i++)
    &#123;
        BitP_Table[i] = Bit_Integer[P_Table[i] - 1];
    &#125;
    return ret;
&#125;
</code></pre>
<h3 id="6、将返回的结果和L组进行异或操作，作为新的R组，并将旧的R组赋值给新的L组"><a href="#6、将返回的结果和L组进行异或操作，作为新的R组，并将旧的R组赋值给新的L组" class="headerlink" title="6、将返回的结果和L组进行异或操作，作为新的R组，并将旧的R组赋值给新的L组"></a>6、<strong>将返回的结果和L组进行异或操作，作为新的R组，并将旧的R组赋值给新的L组</strong></h3><p>代码实现（C语言）：</p>
<pre><code>R[i+1] = L[i] ^ F(R[i], K[i]);
L[i+1] = R[i];
</code></pre>
<h3 id="7、按照3、4、5、6步重复16次"><a href="#7、按照3、4、5、6步重复16次" class="headerlink" title="7、按照3、4、5、6步重复16次"></a><strong>7、按照3、4、5、6步重复16次</strong></h3><p>代码实现（C语言）：</p>
<pre><code>for (int i = 0; i &lt; 16; i++)
&#123;
    //将R组和子密钥组进行F函数运算
    DES_F_Function(BitR_Table[i], BitSubKey[i], Bit_F_Out);
     //L组盒F函数的输出结果进行异或运算
    DES_XOR(BitL_Table[i], Bit_F_Out, BitR_Table[i + 1], 32);
     //Li+1 = Ri
    memcpy(BitL_Table[i + 1], BitR_Table[i], 32);
&#125; 
//L[16]和R[16]进行交叉合并
memcpy(BitRL_Table,         BitR_Table[16], 32);
memcpy(&amp;BitRL_Table[32],    BitL_Table[16], 32);
</code></pre>
<h3 id="8、逆初始值置换"><a href="#8、逆初始值置换" class="headerlink" title="8、逆初始值置换"></a>8、<strong>逆初始值置换</strong></h3><p>对上述16步操作后的结果进行<strong>逆初始值置换</strong>操作,也是类似于初始置换表</p>
<p>代码实现（C语言）：</p>
<pre><code>const unsigned char reIP_Table[64] =
&#123;
    40, 8, 48, 16, 56, 24, 64, 32,
    39, 7, 47, 15, 55, 23, 63, 31,
    38, 6, 46, 14, 54, 22, 62, 30,
    37, 5, 45, 13, 53, 21, 61, 29,
    36, 4, 44, 12, 52, 20, 60, 28,
    35, 3, 43, 11, 51, 19, 59, 27,
    34, 2, 42, 10, 50, 18, 58, 26,
    33, 1, 41,  9, 49, 17, 57, 25
&#125;;
int reIP_Substitution(const unsigned char *BitRL_Table, unsigned char *Bit_reIP_Table)
&#123;
    int ret = 0;
 
    for (int i = 0; i &lt; 64; i++)
    &#123;
        Bit_reIP_Table[i] = BitRL_Table[reIP_Table[i] - 1];
    &#125;
    return ret;
&#125;
</code></pre>
<h3 id="9-密钥的扩展和加密"><a href="#9-密钥的扩展和加密" class="headerlink" title="9.密钥的扩展和加密"></a><strong>9.密钥的扩展和加密</strong></h3><h4 id="PC-1置换："><a href="#PC-1置换：" class="headerlink" title="PC-1置换："></a><strong>PC-1置换</strong>：</h4><p>将64位密钥中的<strong>8、16、24、32、40、48、56、64</strong>位剔除作为校验位。</p>
<p>其余的位进行置换表操作</p>
<pre><code>const unsigned char PC_1_Table[56] =
    &#123;57, 49, 41, 33, 25, 17, 9,  1,
    58, 50, 42, 34, 26, 18, 10, 2,
    59, 51, 43, 35, 27, 19, 11, 3,
    60, 52, 44, 36, 63, 55, 47, 39,
    31, 23, 15, 7,  62, 54, 46, 38,
    30, 22, 14, 6,  61, 53, 45, 37,
    29, 21, 13, 5,  28, 20, 12, 4
&#125;;
 
int PC_1_Substitution(const unsigned char *BitKey, unsigned char *BitKey_PC_1)
&#123;
    int ret = 0;
 
    for (int i = 0; i &lt; 56; i++)
    &#123;
        BitKey_PC_1[i] = BitKey[PC_1_Table[i] - 1];
    &#125;
 
    return ret;
&#125;
</code></pre>
<p>然后对56位数据进行分组，分成C、D组，采用上下分组，再进行16次变化，每次变化后会进行（PC-2置换）生成一次密钥用作<strong>每一轮的加密</strong></p>
<p>每轮变化都进行<strong>整体左位移</strong>操作（并把前面超出范围的两位数据移动到数据的最后面），根据<strong>具体的轮数</strong>位移的位数也不同，其中<strong>1、2、9、16</strong>轮中，位移<strong>1位</strong>，其余轮位移<strong>2位</strong></p>
<pre><code>const unsigned char Bit_Round[16] =
&#123;
    1, 1, 2, 2,
    2, 2, 2, 2,
    1, 2, 2, 2,
    2, 2, 2, 1
&#125;;
int BitRound_L(const unsigned char* SrcBitGroup, unsigned char* DesBitGroup, int nBit)
&#123;
    int ret = 0;
 
    memcpy(DesBitGroup,             &amp;SrcBitGroup[nBit], 28 - nBit);
    memcpy(&amp;DesBitGroup[28 - nBit], SrcBitGroup,        nBit);
    return ret;
&#125;
//将C、D两组进行轮转移位操作    左移
BitRound_L(BitC_Table[i], BitC_Table[i + 1], Bit_Round[i]);
BitRound_L(BitD_Table[i], BitD_Table[i + 1], Bit_Round[i]);
密钥生成算法PC-2置换
</code></pre>
<h4 id="PC-2置换："><a href="#PC-2置换：" class="headerlink" title="PC-2置换："></a><strong>PC-2置换</strong>：</h4><pre><code>const unsigned char PC_2_Table[48]= 
&#123; 14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 
  19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 
  31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 
  39, 56, 34, 53, 46, 42, 50, 36, 29, 32&#125;; 
int PC_2_Substitution(const unsigned char *BitKey, unsigned char *SubKey) 
&#123;                    
    int ret = 0; 
    for (int i = 0; i &lt; 48; i++)&#123; 
    SubKey[i] = BitKey[PC_2_Table[i] - 1]; 
    &#125; 
    return ret; 
&#125; 
</code></pre>
<h2 id="Java代码实现："><a href="#Java代码实现：" class="headerlink" title="Java代码实现："></a><strong>Java代码实现：</strong></h2><p>根据模式的不同有很多实现方式，现展示一种方式,主要抓住特征private static final String ALGORITHM = “DES”;来对加密方式进行判断，标准的DES算法以字符串输出时很容易产生<strong>乱码</strong>，因此输出时需要将其转化为<strong>hex</strong>或者<strong>base64编码</strong>的形式</p>
<pre><code>package abc; 
import javax.crypto.Cipher; 
import javax.crypto.SecretKey; 
import javax.crypto.SecretKeyFactory; 
import javax.crypto.spec.DESKeySpec; 
import java.util.Base64; 
public class DES &#123; 
public static void main(String[] args) throws Exception &#123; 
    DESKeySpec desKey=new DESKeySpec(&quot;12345678&quot;.getBytes()); 
    SecretKeyFactory key=SecretKeyFactory.getInstance(&quot;DES&quot;); 
    SecretKey secretKey=key.generateSecret(desKey); 
    Cipher cipher=Cipher.getInstance(&quot;DES/ECB/PKCS5Padding&quot;); 
    cipher.init(1, secretKey); 
    byte[] res=cipher.doFinal(&quot;a12345678&quot;.getBytes()); 
    System.out.println(Base64.getEncoder().encodeToString(res)); 
    &#125; 
&#125; 
</code></pre>
]]></content>
      <categories>
        <category>加密与解密</category>
      </categories>
      <tags>
        <tag>对称加密算法</tag>
      </tags>
  </entry>
  <entry>
    <title>对称算法（AES篇）</title>
    <url>/2021/08/08/%E5%AF%B9%E7%A7%B0%E7%AE%97%E6%B3%95%EF%BC%88AES%E7%AF%87%EF%BC%89/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准</p>
<span id="more"></span>与技术研究院（NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。

<p>AES为最常见的对称加密算法(微信小程序加密传输就是用这个加密算法的)。对称加密算法也就是加密和解密用相同的密钥。具体的加密流程如下：</p>
<pre><code>graph LR
A(L61q4_Cheng)--&gt;B(公钥A)
B--&gt;C(密文)
C--&gt;D(私钥B)
D--&gt;E(L61q4_Cheng)
</code></pre>
<hr>
<h2 id="加密原理"><a href="#加密原理" class="headerlink" title="加密原理"></a>加密原理</h2><p>AES为分组加密法，把明文分成一组一组的，每组长度相等，每次加密一组数据，直到加密完整个明文，在AES标准规范中，分组长度只能是128位，AES是按照字节进行加密的，也就是说每个分组为16个字节（每个字节8位）。密钥的长度可以使用128位、192位或256位。这导致密钥长度不同，推荐加密的轮数也不同。</p>
<table>
<thead>
<tr>
<th>AES</th>
<th>密钥长度（32位比特字)</th>
<th>分组长度(32位比特字)</th>
<th>加密轮数</th>
</tr>
</thead>
<tbody><tr>
<td>AES-128</td>
<td>4</td>
<td>4</td>
<td>10</td>
</tr>
<tr>
<td>AES-192</td>
<td>6</td>
<td>4</td>
<td>12</td>
</tr>
<tr>
<td>AES-256</td>
<td>8</td>
<td>4</td>
<td>14</td>
</tr>
</tbody></table>
<p>这里实现的是AES-128，也就是密钥的长度为128位，加密轮数为10轮。上面说到，AES的加密公式为C = E(K,P)，在加密函数E中，会执行一个轮函数，并且执行10次这个轮函数，这个轮函数的前9次执行的操作是一样的，只有第10次有所不同。也就是说，一个明文分组会被加密10轮。AES的核心就是实现一轮中的所有操作。</p>
<p>AES的处理单位是字节，128位的输入明文分组P和输入密钥K都被分成16个字节，分别记为P = P0 P1 … P15 和 K = K0 K1 …K15。如，明文分组为P=abcdefghijklmnop,其中的字符a对应P0，p对应P15。一般地，明文分组用字节为单位的正方形矩阵描述，称为状态矩阵。在算法的每一轮中，状态矩阵的内容不断发生变化，最后的结果作为密文输出。该矩阵中字节的排列顺序为从上到下、从左至右依次排列。明文经过AES加密后，已经面目全非。</p>
<h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><p>AES算法可以归纳为四种操作处理，分别为<strong>密钥加法层、字节代换层、行位移层、列混淆层</strong></p>
<p>标准的AES算法密钥和明文都是等长的，一共有128位，196位和256位三种长度，这里重点讲解128位的情况：</p>
<h3 id="1、密钥加法层"><a href="#1、密钥加法层" class="headerlink" title="1、密钥加法层"></a>1、密钥加法层</h3><p>在密钥加法层中有两个输入的参数，分别是明文和子密钥k[0]，而且这两个输入都是128位的。k[0]实际上就等同于密钥k，只需要将两个输入的数据进行按字节异或操作就会得到运算的结果。</p>
<p>代码如下（C语言）：</p>
<pre><code>int AddRoundKey(unsigned char(*PlainArray)[4], unsigned char(*ExtendKeyArray)[44], unsigned int MinCol)
&#123;
    int ret = 0;
 
    for (int i = 0; i &lt; 4; i++)
    &#123;
        for (int j = 0; j &lt; 4; j++)
        &#123;
            PlainArray[i][j] ^= ExtendKeyArray[i][MinCol + j];
        &#125;
    &#125;
 
    return ret;
&#125;
</code></pre>
<h3 id="2、字节代换层"><a href="#2、字节代换层" class="headerlink" title="2、字节代换层"></a>2、字节代换层</h3><p>字节代换层的主要功能是让数据通过S盒完成从一个字节到另一个字节的映射，S盒的计算方式和密钥中S盒计算方式相同。S盒是一个拥有256个字节元素的数组，逆S盒与S盒对应用于AES算法的解密，字节代换层将明文的每一个字节作为数组下标，对进行相关索引操作</p>
<p>若将S盒作为一维数组处理，则只需要将每个字节作为索引下标进行索引</p>
<p>若将S盒作为二维数组，则需要将每个字节的高4位作为第一个下标，第四位作为第二个下标来进行索引</p>
<p>S盒形成过程：S盒是通过将输入的数据进行乘法逆元计算、然后将计算结果进行仿射映射得到的。</p>
<p>状态矩阵中的元素按照下面的方式映射为一个新的字节：把该字节的高4位作为行值，低4位作为列值，取出S盒或者逆S盒中对应的行的元素作为输出。例如，加密时，输出的字节S1为0x12,则查S盒的第0x01行和0x02列，得到值0xc9,然后替换S1原有的0x12为0xc9。</p>
<p>代码如下（C语言）：</p>
<pre><code>//S盒
const unsigned char S_Table[16][16] =
&#123;
    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
&#125;;
 
//字节代换
int Plain_S_Substitution(unsigned char *PlainArray)
&#123;
    int ret = 0;
 
    for (int i = 0; i &lt; 16; i++)
    &#123;
        PlainArray[i] = S_Table[PlainArray[i] &gt;&gt; 4][PlainArray[i] &amp; 0x0F];
    &#125;
 
    return ret;
&#125;
 
 
//逆S盒
const unsigned char ReS_Table[16][16] =
&#123;
    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
&#125;;
//逆字节代换
int Cipher_S_Substitution(unsigned char *CipherArray)
&#123;
    int ret = 0;
 
    for (int i = 0; i &lt; 16; i++)
    &#123;
        CipherArray[i] = ReS_Table[CipherArray[i] &gt;&gt; 4][CipherArray[i] &amp; 0x0F];
    &#125;
 
    return ret;
&#125;
</code></pre>
<h3 id="3、行位移层"><a href="#3、行位移层" class="headerlink" title="3、行位移层"></a>3、行位移层</h3><p>行位移操作最为简单，它是用来将输入数据作为一个4·4的字节矩阵进行处理的，然后将这个矩阵的字节进行位置上的置换。<br><strong>将第一行保持不变，第二行整体向左移1个字节，第三行整体向左位移2个字节，第四行整体左移3个字节</strong></p>
<pre><code>int ShiftRows(unsigned int *PlainArray)
&#123;
    int ret = 0;
 
    //第一行 不移位
    //PlainArray[0] = PlainArray[0];
 
    //第二行 左移8Bit
    PlainArray[1] = (PlainArray[1] &gt;&gt; 8) | (PlainArray[1] &lt;&lt; 24);
 
    //第三行 左移16Bit
    PlainArray[2] = (PlainArray[2] &gt;&gt; 16) | (PlainArray[2] &lt;&lt; 16);
 
    //第四行 左移24Bit
    PlainArray[3] = (PlainArray[3] &gt;&gt; 24) | (PlainArray[3] &lt;&lt; 8);
 
    return ret;
&#125;
</code></pre>
<h3 id="4、列混淆层"><a href="#4、列混淆层" class="headerlink" title="4、列混淆层"></a>4、列混淆层</h3><p>列混淆子层是AES算法中最为复杂的部分，属于扩散层，列混淆操作是AES算法中主要的扩散元素，它混淆了输入矩阵的每一列，使输入的每个字节都会影响到4个输出字节。其中包含了矩阵乘法、伽罗瓦域内加法和乘法的相关知识。<br><strong>伽罗瓦域乘法：</strong></p>
<pre><code>///
//功能:   伽罗瓦域内的乘法运算  GF(128)
//参数:   Num_L           输入的左参数
//      Num_R           输入的右参数
//返回值:计算结果
char GaloisMultiplication(unsigned char Num_L, unsigned char Num_R)
&#123;
    //定义变量
    unsigned char Result = 0;       //伽罗瓦域内乘法计算的结果
 
    while (Num_L)
    &#123;
        //如果Num_L最低位是1就异或Num_R，相当于加上Num_R * 1
        if (Num_L &amp; 0x01)
        &#123;
            Result ^= Num_R;
        &#125;
 
        //Num_L右移一位，相当于除以2
        Num_L = Num_L &gt;&gt; 1;
 
        //如果Num_R最高位为1
        if (Num_R &amp; 0x80)
        &#123;
            //左移一位相当于乘二
            Num_R = Num_R &lt;&lt; 1;     //注：这里会丢失最高位，但是不用担心
 
            Num_R ^= 0x1B;  //计算伽罗瓦域内除法Num_R = Num_R / (x^8(刚好丢失最高位) + x^4 + x^3 + x^1 + 1)
        &#125;
        else
        &#123;
            //左移一位相当于乘二
            Num_R = Num_R &lt;&lt; 1;
        &#125;
    &#125;
    return Result;
&#125;
</code></pre>
<p><strong>矩阵乘法：</strong></p>
<pre><code>//列混淆左乘矩阵
const unsigned char MixArray[4][4] =
&#123;
    0x02, 0x03, 0x01, 0x01,
    0x01, 0x02, 0x03, 0x01,
    0x01, 0x01, 0x02, 0x03,
    0x03, 0x01, 0x01, 0x02
&#125;;
 
int MixColum(unsigned char(*PlainArray)[4])
&#123;
    int ret = 0;
    //定义变量
    unsigned char ArrayTemp[4][4];
 
    //初始化变量
    memcpy(ArrayTemp, PlainArray, 16);
 
    //矩阵乘法 4*4
    for (int i = 0; i &lt; 4; i++)
    &#123;
        for (int j = 0; j &lt; 4; j++)
        &#123;
            PlainArray[i][j] =
                MixArray[i][0] * ArrayTemp[0][j] +
                MixArray[i][1] * ArrayTemp[1][j] +
                MixArray[i][2] * ArrayTemp[2][j] +
                MixArray[i][3] * ArrayTemp[3][j];
        &#125;
    &#125;
 
    return ret;
&#125;
</code></pre>
<p><strong>整体列混淆代码：</strong></p>
<pre><code>const unsigned char MixArray[4][4] =
&#123;
    0x02, 0x03, 0x01, 0x01,
    0x01, 0x02, 0x03, 0x01,
    0x01, 0x01, 0x02, 0x03,
    0x03, 0x01, 0x01, 0x02
&#125;;
 
int MixColum(unsigned char(*PlainArray)[4])
&#123;
    int ret = 0;
    //定义变量
    unsigned char ArrayTemp[4][4];
 
    //初始化变量
    memcpy(ArrayTemp, PlainArray, 16);
 
    //矩阵乘法 4*4
    for (int i = 0; i &lt; 4; i++)
    &#123;
        for (int j = 0; j &lt; 4; j++)
        &#123;
            PlainArray[i][j] =
                GaloisMultiplication(MixArray[i][0], ArrayTemp[0][j]) ^
                GaloisMultiplication(MixArray[i][1], ArrayTemp[1][j]) ^
                GaloisMultiplication(MixArray[i][2], ArrayTemp[2][j]) ^
                GaloisMultiplication(MixArray[i][3], ArrayTemp[3][j]);
        &#125;
    &#125;
    return ret;
&#125;
</code></pre>
<h3 id="加密代码："><a href="#加密代码：" class="headerlink" title="加密代码："></a>加密代码：</h3><pre><code>package abc;
import java.security.Key;
import java.security.SecureRandom;
 
import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import java.util.Base64;
import java.util.Base64.Decoder;
import java.util.Base64.Encoder;
public class Aes2 &#123;
 
    // optional value AES/DES/DESede
    public static String DES = &quot;AES&quot;;
    // optional value AES/DES/DESede
    public static String CIPHER_ALGORITHM = &quot;AES&quot;;
 
    public static Key getKey(String strKey) &#123;
        try &#123;
            if (strKey == null) &#123;
                strKey = &quot;&quot;;
            &#125;
            KeyGenerator _generator = KeyGenerator.getInstance(&quot;AES&quot;);
            SecureRandom secureRandom = SecureRandom.getInstance(&quot;SHA1PRNG&quot;);
            secureRandom.setSeed(strKey.getBytes());
            _generator.init(128, secureRandom);
            return _generator.generateKey();
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(&quot; 密钥出现异常 &quot;);
        &#125;
    &#125;
    public static String decrypt(String message, String key) throws Exception &#123;
        SecureRandom sr = new SecureRandom();
        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);
        Key secureKey = getKey(key);
        cipher.init(Cipher.DECRYPT_MODE, secureKey, sr);
        byte[] res = Base64.getDecoder().decode(message);
        res = cipher.doFinal(res);
        return new String(res);
    &#125;
 
    public static void main(String[] args) throws Exception &#123;
        String message = &quot;123456&quot;;
        String key = &quot;1234567890abcdef&quot;;
        String encryptMsg = encrypt(message, key);
        System.out.println(&quot;加密信息&quot;);
        System.out.println(encryptMsg);
 
        
    &#125;
 
&#125;
</code></pre>
<h2 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h2><pre><code>import java.security.Key;
import java.security.SecureRandom;
import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import java.util.Base64;
import java.util.Base64.Decoder;
import java.util.Base64.Encoder;
public class Aes2 &#123;
 
    // optional value AES/DES/DESede
    public static String DES = &quot;AES&quot;;
    // optional value AES/DES/DESede
    public static String CIPHER_ALGORITHM = &quot;AES&quot;;
 
    public static Key getKey(String strKey) &#123;
        try &#123;
            if (strKey == null) &#123;
                strKey = &quot;&quot;;
            &#125;
            KeyGenerator _generator = KeyGenerator.getInstance(&quot;AES&quot;);
            SecureRandom secureRandom = SecureRandom.getInstance(&quot;SHA1PRNG&quot;);
            secureRandom.setSeed(strKey.getBytes());
            _generator.init(128, secureRandom);
            return _generator.generateKey();
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(&quot; 密钥出现异常 &quot;);
        &#125;
    &#125;
 
    public static String decrypt(String message, String key) throws Exception &#123;
        SecureRandom sr = new SecureRandom();
        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);
        Key secureKey = getKey(key);
        cipher.init(Cipher.DECRYPT_MODE, secureKey, sr);
        byte[] res = Base64.getDecoder().decode(message);
        res = cipher.doFinal(res);
        return new String(res);
    &#125;
 
    public static void main(String[] args) throws Exception &#123;
        String message = &quot;123456&quot;;
        String key = &quot;1234567890abcdef&quot;;
        String decryptedMsg = decrypt(encryptMsg, key);
        System.out.println(&quot;解密信息&quot;);
        System.out.println(decryptedMsg);
    &#125;
 
&#125;
</code></pre>
]]></content>
      <categories>
        <category>加密与解密</category>
      </categories>
      <tags>
        <tag>对称加密算法</tag>
      </tags>
  </entry>
  <entry>
    <title>解决安卓模拟器安装Xposed框架问题Could not load available ZIP files.Pull down to try again</title>
    <url>/2021/08/15/%E8%A7%A3%E5%86%B3%E5%AE%89%E5%8D%93%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AE%89%E8%A3%85Xposed%E6%A1%86%E6%9E%B6%E9%97%AE%E9%A2%98Could%20not%20load%20available%20ZIP%20files.Pull%20down%20to%20try%20again/</url>
    <content><![CDATA[<p>将Xposed Installer安装在模拟器上显示如下界面：</p>
<span id="more"></span>
<p><img src="https://i.loli.net/2021/08/16/58Fv1nTKyrAl3mI.png" alt="QQ截图20210815172904.png"></p>
<h3 id="具体步骤："><a href="#具体步骤：" class="headerlink" title="具体步骤："></a>具体步骤：</h3><h4 id="1、下载Xposed"><a href="#1、下载Xposed" class="headerlink" title="1、下载Xposed"></a>1、下载Xposed</h4><p>下载自己安卓版本对应的SDK，下载链接 <a href="https://dl-xda.xposed.info/framework/">https://dl-xda.xposed.info/framework/</a></p>
<p>(注：对应的SDK版本参考：<br><a href="https://l61q4cheng.github.io/2021/08/15/Android%E5%90%84%E7%89%88%E6%9C%AC%E5%AF%B9%E5%BA%94%E7%9A%84SDK%E7%89%88%E6%9C%AC/#more">https://l61q4cheng.github.io/2021/08/15/Android%E5%90%84%E7%89%88%E6%9C%AC%E5%AF%B9%E5%BA%94%E7%9A%84SDK%E7%89%88%E6%9C%AC/#more</a>)</p>
<p>注：sdk版本下载错误会影响安装结果，笔者这里下载SDK22，该模拟器为x86，因此下载x86版本。</p>
<h4 id="2、下载script-txt"><a href="#2、下载script-txt" class="headerlink" title="2、下载script.txt"></a>2、下载script.txt</h4><p>下载链接：<a href="https://forum.xda-developers.com/attachments/script-txt.4489568/">https://forum.xda-developers.com/attachments/script-txt.4489568/</a></p>
<p>下载之后将后缀名改为script.sh。</p>
<h4 id="3、创建xposed文件夹"><a href="#3、创建xposed文件夹" class="headerlink" title="3、创建xposed文件夹"></a>3、创建xposed文件夹</h4><p>创建文件名为xposed的文件夹，将第一步下载的Xposed压缩包中的system文件和script.sh文件放在该文件夹中。如图：</p>
<p><img src="https://i.loli.net/2021/08/16/iea5Y2Xd3syl7GI.png" alt="QQ截图20210815174814.png"></p>
<h4 id="4、执行安装命令"><a href="#4、执行安装命令" class="headerlink" title="4、执行安装命令"></a>4、执行安装命令</h4><p>在模拟器安装目录下，地址栏输入cmd操作如下命令。</p>
<p>第一步    adb devices     #查看是否检测到正在运行的运行模拟器</p>
<p>第二步    adb remount</p>
<p>第三步    adb push xposed文件夹路径 /system</p>
<p><img src="https://i.loli.net/2021/08/16/Vq9sTytR1H8v24h.png" alt="QQ截图20210815175953.png"></p>
<p>第四步    adb shell</p>
<p>第五步    su</p>
<p>第六步    cd /system</p>
<p>第七步    mount -o remount -w /system</p>
<p>第八步    sh script.sh<br><img src="https://i.loli.net/2021/08/16/JTkN56lZwS7Khfu.png" alt="QQ截图20210815180344.png"></p>
<h4 id="5、激活成功"><a href="#5、激活成功" class="headerlink" title="5、激活成功"></a>5、激活成功</h4><p>重启服务器，重新打开Xposed Installer</p>
<p><img src="https://i.loli.net/2021/08/16/8T2gKozdeF1BPGM.png" alt="QQ截图20210815180724.png"></p>
]]></content>
      <categories>
        <category>Xposed框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Xposed框架</tag>
        <tag>模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title>非对称加密算法</title>
    <url>/2021/08/05/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h3><p>非对称加密算法需要<strong>两个密钥</strong>：公开密钥（publickey:简称公钥）和私有密钥（privatekey:简称私钥）。公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密。因为加密和解密使用<span id="more"></span>的是两个不同的密钥，所以这种算法叫作非对称加密算法。 </p>
<h3 id="基本过程"><a href="#基本过程" class="headerlink" title="基本过程"></a>基本过程</h3><p>甲方生成一对密钥并将公钥公开，需要向甲方发送信息的其他角色(乙方)使用该密钥(甲方的公钥)对机密信息进行加密后再发送给甲方；甲方再用自己私钥对加密后的信息进行解密。甲方想要回复乙方时正好相反，使用乙方的公钥对数据进行加密，同理，乙方使用自己的私钥来进行解密。</p>
<pre><code>graph LR
A(L61q4_Cheng)--&gt;B(公钥A)
B--&gt;C(密文)
C--&gt;D(私钥B)
D--&gt;E(L61q4_Cheng)
</code></pre>
<p>注：私钥B中包含公钥A</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快。对称密码体制中只有一种密钥，并且是非公开的，如果要解密就得让对方知道密钥。所以保证其安全性就是保证密钥的安全，而非对称密钥体制有两种密钥，其中一个是公开的，这样就可以不需要像对称密码那样传输对方的密钥了。</p>
<p>1、使用公钥加密，使用私钥解密。</p>
<p>2、公钥是公开的，私钥是保密的（私钥包含公钥信息）。</p>
<p>3、密钥不能随便写，由特定函数生成。</p>
<p>4、加密处理安全，但性能差，单次加密长度有限。</p>
<blockquote>
<p>pkcslpadding 明文最大字节数为密钥字节数-11，明文与密钥等长。<br>NoPadding 明文最大字节数为密钥字节数，明文与密钥等长。</p>
</blockquote>
<p>5、可用于数据交换，也可用于数据校验。</p>
<p>注：私钥格式有两种，Java中密钥格式为PKCS#8，其他为PKCS#1。</p>
<p>使用PKCS#8，私钥开头为</p>
<blockquote>
<p>—-BEGIN  PRIVATE KEY—</p>
</blockquote>
<p>使用PKCS#1，私钥格式为</p>
<blockquote>
<p>—-BEGIN RSA PRIVATE KEY—</p>
</blockquote>
<h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><p>非对称加密体系不要求通信双方事先传递密钥或有任何约定就能完成保密通信，并且密钥管理方便，可实现防止假冒和抵赖，因此，更适合网络通信中的保密通信要求。</p>
<h3 id="主要算法"><a href="#主要算法" class="headerlink" title="主要算法"></a>主要算法</h3><p>RSA、Elgamal、背包算法、Rabin、D-H、ECC (椭圆曲线加密算法)。使用最广泛的是 RSA 算法，Elgamal 是另一种常用的非对称加密算法。</p>
<h3 id="两种加密算法结合的套路"><a href="#两种加密算法结合的套路" class="headerlink" title="两种加密算法结合的套路"></a>两种加密算法结合的套路</h3><p>1、随机生成密钥，用作对称加密算法（AES/DES/3DES）的加密数据。</p>
<p>2、RSA对密钥进行加密，提交加密后的密钥和加密后的数据给服务器。</p>
]]></content>
      <categories>
        <category>加密与解密</category>
      </categories>
      <tags>
        <tag>非对称加密算法</tag>
      </tags>
  </entry>
  <entry>
    <title>非对称算法（RSA篇）</title>
    <url>/2021/08/05/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E7%AE%97%E6%B3%95%EF%BC%88RSA%E7%AF%87%EF%BC%89/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>RSA加密算法是一种非对称加密算法，在RSA算法中，加密密钥（即公开密钥）PK是公开信息，而解密密钥（即秘密密钥）SK是需要保密的。加密算法E和解密算法D也都是公开的。对极大整数做因数分解的难度决定了RSA算法的可靠性。</p>
<span id="more"></span>

<h3 id="加密原理"><a href="#加密原理" class="headerlink" title="加密原理"></a>加密原理</h3><h4 id="一、生成公钥和私钥"><a href="#一、生成公钥和私钥" class="headerlink" title="一、生成公钥和私钥"></a>一、生成公钥和私钥</h4><ol>
<li>随机生成两个素数P、Q。</li>
<li>将P、Q两个素数相乘得到一个数N。</li>
<li>计算N的欧拉函数M，M=(P-1)*(Q-1)。</li>
<li>选择一个整数E使其与M互质。</li>
<li>给定一个整数D，使得(E*D)%M=1。</li>
<li>得到N、E、D三个数，其中（N、E）作为公钥，（N、D）作为私钥（公钥和私钥可以互换）。<h4 id="二、生成密文"><a href="#二、生成密文" class="headerlink" title="二、生成密文"></a>二、生成密文</h4>使用公钥（N、E）对data进行加密。<br>加密过程：<strong>这里的E相当于公钥</strong></li>
</ol>
<pre><code class="math">data^E mod N = [data]
</code></pre>
<h4 id="三、密文解密"><a href="#三、密文解密" class="headerlink" title="三、密文解密"></a>三、密文解密</h4><p>使用私钥（N、D）对密文进行解密。<br>解密过程：<strong>这里的D相当于密钥</strong></p>
<pre><code class="math">[data]^D mod N = data
</code></pre>
<h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p><img src="D:\Desktop\QQ截图20211008135924.png" alt="QQ截图20211008135924"></p>
<p>注：欧拉函数f(n)表示在小于或等于n的正整数中，有多少个与n互质的数</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><pre><code>public class RSA &#123;
    private int N;  // 和公钥E一起分发出去
    private int E; // E是公钥，随机选取（必须和T互质）
    private int D; // D是密钥（D和E可以互换）
    public RSA() &#123;
        createKey();
    &#125;
    // 产生密钥
    private void createKey() &#123;
        // 产生两个随机的素数
        int p=61,q=53;
        // 计算N和T
        N = p*q;
        int t = (p-1)*(q-1);
        // 选择E（和T互质就行）
        E = 17;
        // 计算D
        int[] r = new int[2];
        Gcd.extendGcd(E, t, r); // 调用扩充欧几里得算法计算D
        D = r[0];
        // 调整d（d为正数）
        while(D &lt; 0) D +=t;
    &#125;

    /**
     * 利用公钥对密文m加密
     * @param m 必须是整数，且m必须小于N
     * @return c=pow(m,E)%N
     */
    public int encrypt(int m) &#123; // 注意，这里很容易溢出（虽然此算法已经极度简化了）
        BigInteger bm = BigInteger.valueOf(m);
        return bm.pow(E).mod(BigInteger.valueOf(N)).intValue();
    &#125;

    /**
     * 利用密钥对明文c解密
     * @param c
     * @return m1=pow(c, D)%N
     */
    public int decrypt(int c) &#123; // 同样考虑溢出情况
        BigInteger bc = BigInteger.valueOf(c);
        return bc.pow(D).mod(BigInteger.valueOf(N)).intValue();
    &#125;
    public int getPublicKey() &#123;
        return E;
    &#125;
    public void setPublicKey(int E) &#123;
        this.E = E;
    &#125;
    public int getN() &#123;
        return N;
    &#125;
    public void setN(int N) &#123;
        this.N = N;
    &#125;
    public static void main(String[] args) &#123;
        RSA rsa = new RSA();
        System.out.println(&quot;公钥：E=&quot;+rsa.getPublicKey()+&quot;,N=&quot;+rsa.getN()); // 打印公钥
        int m = 65; // 明文
        System.out.println(&quot;密文：&quot;+m);
        int c = rsa.encrypt(m); // 对明文m加密，得到密文c
        System.out.println(&quot;明文：&quot;+c);
        int m1 = rsa.decrypt(c); // 对密文c解密，得到明文m1
        System.out.println(&quot;解密出来的密文：&quot;+m1);
    &#125;
&#125;
</code></pre>
<h4 id="代码实现（python）"><a href="#代码实现（python）" class="headerlink" title="代码实现（python）"></a>代码实现（python）</h4><pre><code class="python">def isPrime(number):
    import math
    i = 2
    sqrtnum = (int)(math.sqrt(number))
    for i in range(2, sqrtnum + 1):
        if number % i == 0:
            return False
        i = i + 1
    return True

def is_ET_Prime(ee, tt):
    while tt != 0:
        a = ee
        ee = tt
        tt = a % tt
    if ee == 1:
        return True
    else:
        return False
def get_publickey(k, t):
    d = 0
    while ((d * k) % t != 1):
        d += 1
    return d
def encryption(plain, d, n):
    re = (plain ** d) % n

    return re

if __name__ == &quot;__main__&quot;:
    print
    &quot;~&quot; * 70
    Flag = False
    while True:
        p = int(input(&quot;please input a prime p:&quot;))
        q = int(input(&quot;please input a prime q:&quot;))

        if (isPrime(p) and isPrime(q)):
            break
        else:
            print
            &quot;p or q is not prime!&quot;
            continue
    print
    &quot;p=&quot;, p, &quot;q=&quot;, q
    n = q * p
    t = (q - 1) * (p - 1)
    print(&quot;n=&quot;, n, &quot;t=&quot;, t)
    print(&quot;~&quot; * 70)
    Flag == False
    while Flag == False:
        e = int(input(&quot;please input a private key:&quot;))
        Flag = is_ET_Prime(e, t)
        if Flag == False:
            print(&quot;e is not prime with the t!&quot;)
    print(&quot;the private key e=&quot;, e)
    d = get_publickey(e, t)
    print(&quot;the public key d=&quot;, d)
    plain = int(ord(input(&quot;please input the plain you want to entrypted:&quot;)))
    encry = encryption(plain, d, n)
    print(&quot;plain&quot;, plain, &quot;is encrypted as&quot;, encry)
    #print(encry)
    plain1 = encryption(encry, e, n)
    print(&quot;encrypt&quot;, encry, &quot;is decrypted as&quot;, plain1)
</code></pre>
]]></content>
      <categories>
        <category>加密与解密</category>
      </categories>
      <tags>
        <tag>非对称加密算法</tag>
      </tags>
  </entry>
  <entry>
    <title>移动通信安全技术学习笔记</title>
    <url>/2023/09/07/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF-PPT/</url>
    <content><![CDATA[<h1 id="移动通信安全技术学习笔记"><a href="#移动通信安全技术学习笔记" class="headerlink" title="移动通信安全技术学习笔记"></a>移动通信安全技术学习笔记</h1><span id="more"></span>

<p><img src="https://s2.loli.net/2023/09/07/EZ8V9MwJyWqvldO.png" alt="image-20230728183533114"></p>
<h1 id="2G移动通信安全（GSM）-话音短信业务"><a href="#2G移动通信安全（GSM）-话音短信业务" class="headerlink" title="2G移动通信安全（GSM）-话音短信业务"></a>2G移动通信安全（GSM）-话音短信业务</h1><h2 id="一、网络结构"><a href="#一、网络结构" class="headerlink" title="一、网络结构"></a>一、网络结构</h2><p><img src="https://s2.loli.net/2023/09/07/KYNzsruJLMSiaF3.png" alt="image-20230726160948457"></p>
<p><strong>移动台MS</strong>：有移动用户控制，与基站建立双向的无线通信，包括移动终端和用户身份模块SIM。移动终端完成话音编码、信道编码、信息加密、信息的调制解调和发射接收，通过空中接口接入无线网络。</p>
<p><strong>SIM卡</strong>：包含认证用户身份的所有信息。只有插入SIM卡后移动终端才能接入网络。</p>
<p>从2G开始，移动通信系统实现了移动终端和SIM卡的分离。</p>
<h3 id="1、BSS（基站子系统）"><a href="#1、BSS（基站子系统）" class="headerlink" title="1、BSS（基站子系统）"></a>1、BSS（基站子系统）</h3><ul>
<li><strong>基站收发信机（BTS）</strong>：负责无线传输，包括收、发信机和天线等，在网络中固定部分和无线部分之间提供中继服务。</li>
<li><strong>基站控制器（BSC）</strong>：负责控制和管理基站，包括无线信道的分配、释放、越区切换等。通常一个控制器同时管理多个BTS。</li>
</ul>
<h3 id="2、NSS（网络交换子系统）"><a href="#2、NSS（网络交换子系统）" class="headerlink" title="2、NSS（网络交换子系统）"></a>2、NSS（网络交换子系统）</h3><ul>
<li><strong>移动交换中心（MSC）</strong>：是整个GSM网络的核心，提供基本交换功能，实现移动用户和固定用户的通信连接，并提供位置登记与更新、越区切换和漫游等服务。</li>
<li><strong>用户和终端设备数据库</strong>：<ul>
<li><strong>VLR</strong>：拜访位置寄存器，是一个动态数据库。通常与MSC合设，协助MSC记录当前进入其控制区域内的来访移动用户的有关数据。用户离开时信息被删除。</li>
<li><strong>AUC</strong>：认证中心，GSM系统的安全性管理单元，存储用户的鉴权和加密信息，用来保护用户的安全性和防止非法用户接入网络。一般与HLR合设，向HLR提供鉴权参数。</li>
<li><strong>HLR</strong>：归属位置寄存器，系统的中央数据库。存储管辖范围内所有的签约移动用户的信息，包括移动用户号码、移动用户的类别、补充业务等静态数据，还包括移动用户漫游时的有关动态数据。</li>
<li><strong>EIR</strong>：移动设备识别寄存器，存储了移动设备的国际移动设备识别码（IMEI），可以保证入网移动设备是拥有入网许可的。</li>
</ul>
</li>
</ul>
<h3 id="3、OSS（操作与维护子系统）"><a href="#3、OSS（操作与维护子系统）" class="headerlink" title="3、OSS（操作与维护子系统）"></a>3、OSS（操作与维护子系统）</h3><ul>
<li><strong>操作与维护中心（OMC）</strong>：对BSC、MSC和VLR等设备的各个功能单元的维护和操作。</li>
</ul>
<h2 id="二、安全性"><a href="#二、安全性" class="headerlink" title="二、安全性"></a>二、安全性</h2><ul>
<li>GSM系统业务单一，只有话音、短信、窄带数据业务。利益想官方只有用户和运营商。</li>
<li><strong>安全目标</strong>：一是防止未授权的用户接入网络，二是保护用户的隐私权。</li>
<li>信令：通信系统中的控制指令。</li>
<li><strong>安全实现</strong>：<ol>
<li><strong>在无线链路上隐藏用户的身份，如使用临时识别号(TMSI)替代国际移动用户识别码IMSI。</strong></li>
<li>在无线链路采用加密技术，保护用户语音和部分信令数据。</li>
<li>采用鉴权机制，对接入网络的用户身份进行鉴别。</li>
<li>通过个人化的用户身份模块（SIM）存储用户的安全相关信息。并使用PIN码实现对SIM卡的访问控制。</li>
</ol>
</li>
</ul>
<h2 id="三、SIM卡"><a href="#三、SIM卡" class="headerlink" title="三、SIM卡"></a>三、SIM卡</h2><p><strong>Subscriber Identity Model用户身份模块</strong></p>
<ul>
<li>可以被应用于不同的GSM手机，实现机卡分离。</li>
<li>SIM卡中存储有持卡者的身份识别信息(IMSI)，用户数据、保密数据(<strong>鉴权密钥Ki</strong>)和**鉴权算法(A3/A8)**等。</li>
<li>SIM卡是一个装有微处理器的芯片卡，内部有5个模块，并且每个模块都有对应一个功能：微处理器CPU（8位）、程序存储器ROM、工作存储器RAM、数据存储器EEPROM和串行通信单元。<img src="https://s2.loli.net/2023/09/07/TPV65sY1dR4KMUW.png" alt="image-20230726171216741"></li>
</ul>
<p>SIM卡中存储的内容：</p>
<p>1、<strong>鉴权密钥Ki</strong>：由运营商在SIM卡初始化时写入，与SIM卡中IMSI一一对应，<strong>一旦写入后无法再通过I/O接口被外界读取，所需要使用Ki算法都仅在SIM卡内部运行。</strong></p>
<p>2、<strong>保密算法</strong>：鉴权算法A3/A8，由制造商生产SIM卡时写入，算法保密，由运营商掌握。</p>
<p>3、唯一的国际移动身份识别号（IMSI），用以标识用户身份。</p>
<p>4、空口加密密钥Kc：鉴权过程中由Ki导出，并通过SIM卡的IO口发送给移动终端来完成对空口链路的加密。</p>
<p>5、相关标识： IMSI：国际移动用户标示号；IMEI：国际移动设备身份码。</p>
<ul>
<li><strong>LAI</strong>：区域识别码</li>
<li><strong>LAC</strong>：Location Area Code位置区域码，最多不超过16位，用于识别GSM网络中位置区域的固定长度的码字，由运营商自定义。</li>
<li><strong>小区识别码</strong>：一个位置区分为若干个小区，每个小区用一个小区识别码CI来标识。</li>
<li>BSIC：Base StationIdentity Code基站识别码，用于区分不同地区边界采用相同载波的相邻基站。</li>
<li><strong>NCC</strong>：网络色码，用于识别相邻的移动通信网络。</li>
<li><strong>BCC</strong>：基站收发台(BTS)色码，用于识别同一载波的不同基站。<img src="https://s2.loli.net/2023/09/07/gNv4eRKzZlcEC3B.png" alt="image-20230726173207345"></li>
</ul>
<h2 id="四、GSM空口链路的用户身份识别"><a href="#四、GSM空口链路的用户身份识别" class="headerlink" title="四、GSM空口链路的用户身份识别"></a>四、GSM空口链路的用户身份识别</h2><h3 id="1、MS在新的VLR使用TMSI进行位置更新时的鉴权过程"><a href="#1、MS在新的VLR使用TMSI进行位置更新时的鉴权过程" class="headerlink" title="1、MS在新的VLR使用TMSI进行位置更新时的鉴权过程"></a>1、MS在新的VLR使用TMSI进行位置更新时的鉴权过程</h3><ol>
<li>当MS进入VLRn时，通过监听在广播信道中进行广播的位置区域标识LAI信息，发现以前存储在SIM卡中的LAIo（表示旧的位置区域标识）和现在接收到的LAIn（表示新的位置区域标识）不相同，移动台必须进行新的认证。</li>
<li>MS发送LAIo或TMSIo标识给新的VLRn。</li>
<li>VLRn根据收到的TMSIo，发送TMSIo到MSC/VLRo，查清TMSIo代表的IMSI身份。</li>
<li>MSC/VLRo将没使用过的鉴权三元组发送VLRn。</li>
<li>VLRn选择一个认证向量组中的随机数发送给MS,从而完成用户鉴权</li>
</ol>
<h3 id="2、用户第一次使用移动台时的鉴权过程（需要IMSI）"><a href="#2、用户第一次使用移动台时的鉴权过程（需要IMSI）" class="headerlink" title="2、用户第一次使用移动台时的鉴权过程（需要IMSI）"></a>2、用户第一次使用移动台时的鉴权过程（需要IMSI）</h3><ol>
<li>MS读取存在SIM卡中缺省的TMSI，并将其发送到网络端的MSC/VLR。</li>
<li>由于MSC/VLR不知道TMSI，因此请求MS发送IMSI。</li>
<li>MS发送IMSI到MSC/VLR。</li>
<li>MSC/VLR发送IMSI给HLR以获取该用户的鉴权三元组，同时给MS分配一个新的TMSI。</li>
<li>MS重新发起认证请求。</li>
</ol>
<h3 id="3、MS在新VLRn使用IMSI进行位置更新时的鉴权过程"><a href="#3、MS在新VLRn使用IMSI进行位置更新时的鉴权过程" class="headerlink" title="3、MS在新VLRn使用IMSI进行位置更新时的鉴权过程"></a>3、MS在新VLRn使用IMSI进行位置更新时的鉴权过程</h3><ol>
<li>当原来的MSC/VLRo不可达到(或者TMSI信息VLRo没有时)，须使用IMSI进行认证。</li>
<li>MS发送IMSI给VLRn，VLRn根据IMSI确定MS的归属HLR/AuC,并发送请求鉴权三元组。</li>
<li>HLR/AuC收到请求后，发送认证鉴权三元组至MSC/VLRn。</li>
<li>MSC/VLRn选择随机数发给MS，完成对用户的认证。</li>
</ol>
<p>一般情况下，空口信道的用户身份是使用TMSI代替IMSI进行传输的，且相关信息会被保存在VLR数据库中，但在下列两种情况下，网络段必须要求移动段在空口明文发送IMSI。第一、SIM卡第一次入网。第二、访问位置寄存器VLR中域用户有关数据丢失。这两种情况的本质都是用户尝试接入VLR，但无法通过TMSI查询到对应的IMSI，无法确认用户身份。</p>
<h2 id="五、GSM鉴权"><a href="#五、GSM鉴权" class="headerlink" title="五、GSM鉴权"></a>五、GSM鉴权</h2><p>GSM网络需要通过用户鉴权机制来鉴别当前接入网络的SIM的合法性，为后续GSM空口加密派生会话密钥。</p>
<p>用户入网时，一对唯一的{IMSI，Ki}已经被存储到SIM卡中，同时还有一份副本存储在AUC中。AUC和SIM都实现了鉴权算法A3/A8，A3用于生成鉴权响应SRES，A8用于生成空口加密密钥Kc。</p>
<p>鉴权三元组{Rand，SRES，Kc}</p>
<h3 id="鉴权过程"><a href="#鉴权过程" class="headerlink" title="鉴权过程"></a>鉴权过程</h3><ol>
<li>移动台向VLR注册时，MSC/VLR选择一个鉴权三元组，并将随机数发给MS。</li>
<li>MS收到随机数后，利用SIM卡中的A3、A8和鉴权密钥Ki计算出SRES和Kc，并将SRES发送给MSC/VLR。</li>
<li>MSC/VLR比较三元组中的SRES与MS发送的SRES一致性，一致则证明移动台的身份。</li>
</ol>
<h2 id="六、SIM卡克隆"><a href="#六、SIM卡克隆" class="headerlink" title="六、SIM卡克隆"></a>六、SIM卡克隆</h2><p>将正式渠道发行的SIM卡信息复制到其他卡片上，核心问题是对SIM卡内存储的鉴权密钥Ki的破解。</p>
<h2 id="七、Comp128算法"><a href="#七、Comp128算法" class="headerlink" title="七、Comp128算法"></a>七、Comp128算法</h2><p><img src="https://s2.loli.net/2023/09/07/DA5Z1mJGa9zVsMr.png" alt="image-20230728103109962"></p>
<h2 id="八、GSM的空口加密"><a href="#八、GSM的空口加密" class="headerlink" title="八、GSM的空口加密"></a>八、GSM的空口加密</h2><p><img src="../../../../Desktop/1/photo/uojCHpzcl4gR5OY.png"></p>
<h1 id="2G公众移动通信系统安全（GPRS）-数据"><a href="#2G公众移动通信系统安全（GPRS）-数据" class="headerlink" title="2G公众移动通信系统安全（GPRS）-数据"></a>2G公众移动通信系统安全（GPRS）-数据</h1><p>GPRS，通用分组无线业务。引入分组交换域，支持采用分组方式进行数据的传输。适用于间断的、突发的、频繁的、少量的数据传输，也适用于偶尔的大量数据传输。在信道上提供TCP/IP连接，可以用于Internet连接，数据传输等应用。</p>
<h2 id="一、结构"><a href="#一、结构" class="headerlink" title="一、结构"></a>一、结构</h2><p><strong>SGSN</strong>：服务GPRS支持节点，记录移动台的当前位置信息，且在移动台和GGSN之间完成移动分组数据的发送和接收。</p>
<p><strong>GGSN</strong>：GPRS网关支持节点，起网关作用，可以把GSM网中的GPRS分组数据包进行转换，实现和多种不同的数据网络连接，如ISDN、PSPDN和LAN等。<img src="https://s2.loli.net/2023/09/07/LcuzmBS9Qa8Yfkb.png" alt="image-20230728105333586"></p>
<h2 id="二、特点"><a href="#二、特点" class="headerlink" title="二、特点"></a>二、特点</h2><ol>
<li>传输速率相较于GSM大幅度提高。</li>
<li>只有在发送和接收数据时才占用资源，多个用户可高效的共享同一无线信道。</li>
<li>快速建立连接，接入等待时间短。</li>
<li>提供实时在线功能，用户将始终处于连线和在线状态。</li>
</ol>
<h2 id="三、安全性"><a href="#三、安全性" class="headerlink" title="三、安全性"></a>三、安全性</h2><ol>
<li>采用GEA算法实现MS和SGSN之间用户信息和信令信息的加密保护。</li>
<li>与GSM鉴权机制和身份隐藏（使用临时标识符）相同。</li>
<li>利用GPRS隧道协议GTP对IP或者X.25分组封装，实现二者之间的数据传输；</li>
<li>IPSec为GTP信令和业务数据加密，令其可以通过外部IP网络安全传送。<img src="https://s2.loli.net/2023/09/07/Kv6BtdwqAzSlGi1.png" alt="image-20230728110102228"></li>
</ol>
<h3 id="1、身份隐藏"><a href="#1、身份隐藏" class="headerlink" title="1、身份隐藏"></a>1、身份隐藏</h3><p>GPRS采用电路交换和分组交换，不同交换领域采用不同的临时身份识别码。32位比特数据的最高两位区分。</p>
<p>电路交换：TMIS：0~BFFF</p>
<p>分组交换：P_TMIS：BFFF~FFFF</p>
<h3 id="2、鉴权过程"><a href="#2、鉴权过程" class="headerlink" title="2、鉴权过程"></a>2、鉴权过程</h3><ol>
<li>移动台发送请求到SGSN。</li>
<li>SGSN发送鉴权数据请求消息到HLR/AUC，请求用户的鉴权数据。</li>
<li>HLR/AUC首先产生一个随机数RAND，然后由用户的密钥Ki和随机数Rand经A3算法产生签名响应SRES，经A8算法产生加密密钥GPRS_Kc，发送{Rand，SRES，GPRS_Kc}发送给SGSN。</li>
<li>SGSN向MS发送鉴权请求消息，其中包括鉴权三元组中的Rand。</li>
<li>移动台利用SIM卡中保存的密钥和对应的算法，利用SRES和GPRS_Kc，并将鉴权响应SRES通过鉴权响应发送SGSN。</li>
<li>比较判定。</li>
</ol>
<h1 id="3G移动通信安全（UMTS）"><a href="#3G移动通信安全（UMTS）" class="headerlink" title="3G移动通信安全（UMTS）"></a>3G移动通信安全（UMTS）</h1><p><img src="https://s2.loli.net/2023/09/07/akUlyN8KVLseT31.png" alt="image-20230728120613033"></p>
<h2 id="一、组成"><a href="#一、组成" class="headerlink" title="一、组成"></a>一、组成</h2><ul>
<li><strong>UE（移动终端）</strong>：由<strong>移动设备（ME）</strong>和<strong>通用用户识别模块（USIM）</strong>组成。</li>
<li><strong>无线接入网（RAN）</strong>：包括两个网元（NodeB和RNC）。<strong>NodeB是3G中的基站</strong>，相当于GSM中的BTS。<strong>RNC是无线网络控制器</strong>，想的那个与GSM中的BSC，管理和控制下面的多个基站。主要提供无线资源管理和控制功能（无线资源管理用于保持无线传播的稳定性和无线连接的服务质量，控制功能包含所有和无线承载建立、保持、释放相关的功能）。</li>
<li><strong>核心网（CN）</strong>：基本沿用了GSM的电路交换域和GPRS的分组交换域，但进一步分为了<strong>服务网络SN</strong>（提供交换和漫游的部分，包括VLR/MSC、SGSN）和<strong>归属环境HE</strong>（包括有关用户的静态信息，包括HLR/AUC）。</li>
</ul>
<h2 id="二、3G系统的安全体系结构"><a href="#二、3G系统的安全体系结构" class="headerlink" title="二、3G系统的安全体系结构"></a>二、3G系统的安全体系结构</h2><p><img src="https://s2.loli.net/2023/09/07/5nBpr1QIN2yhwzF.png" alt="image-20230728122207549"></p>
<h3 id="1、五个安全域"><a href="#1、五个安全域" class="headerlink" title="1、五个安全域"></a>1、五个安全域</h3><ol>
<li>接入域安全：为用户提供安全的3G网络接入，防止对无线链路的攻击，包括用户身份保密、用户数据保密、用户和网络间的双向认证等。</li>
<li>网络域安全：在运营商节点间提供安全的信令数据交换，包括网络实体间的相互认证、信息加密和完整性保护。</li>
<li>用户域安全：提供对无线终端的安全访问，包括用户和USIM的认证、USIM和终端间的认证。</li>
<li>应用层安全：保护用户与服务提供商间在应用层面安全的交换数据，包括应用层安全机制。</li>
<li>安全的可视性和可配性：使得用户指导网络的安全服务是否在运行，以及它提供的服务是否安全。</li>
</ol>
<h2 id="三、网络访问安全性："><a href="#三、网络访问安全性：" class="headerlink" title="三、网络访问安全性："></a>三、网络访问安全性：</h2><h3 id="1、用户身份保密技术"><a href="#1、用户身份保密技术" class="headerlink" title="1、用户身份保密技术"></a>1、用户身份保密技术</h3><p>身份保密、位置保密、不可追踪（TMSI不能长期代表用户身份），<strong>核心还是在无线信道上隐藏用户身份。</strong></p>
<p>两种机制：1、UIC（使用TMSI代替IMSI，沿用GSM）。2、EUIC（使用加密的IMSI，未实现）。<img src="https://s2.loli.net/2023/09/07/kGp9UQ2Bg7OlRCj.png" alt="image-20230728130321908"></p>
<h3 id="2、认证与密钥协商"><a href="#2、认证与密钥协商" class="headerlink" title="2、认证与密钥协商"></a>2、认证与密钥协商</h3><p><img src="https://s2.loli.net/2023/09/07/hZ6zBocaNqV8PjC.png" alt="image-20230728130911388"></p>
<ol>
<li><p>MS认证数据请求。</p>
</li>
<li><p>HE/HLR生成认证向量。</p>
</li>
<li><p>SN认证数据应答，存储认证向量。</p>
</li>
<li><p>SN选择某认证向量i，用户认证请求RAND(i)||AUTN(i)。</p>
</li>
<li><p>用户认证AUTN(i)，计算并认证应答RES(i)。</p>
</li>
<li><p>SN比较RES(i)和XRES(i)，计算CK_i和IK_i。</p>
<p>注：AUTN认证令牌，RES用户应答信息，<strong>CK数据加密密钥，IK数据完整性密钥</strong>。</p>
</li>
</ol>
<h4 id="（1）AKA的目的"><a href="#（1）AKA的目的" class="headerlink" title="（1）AKA的目的"></a>（1）AKA的目的</h4><ul>
<li>完成网络与用户的双向认证(由AUTN完成UE认证网络端)</li>
<li>生成加密密钥(CK) 和完整性密钥(IK)</li>
<li>确保CK/IK 的新鲜性，即以前没有使用过(由Rand保证)</li>
<li>安全性：1、双向认证，认证完成后提供加密密钥和完整性密钥，防止假基站攻击；2、密钥的分发没有在无线信道上传输，AV在固定网内的传输也由网络域安全提供保障；3、密钥的新鲜性，由新的随机数提供，防止重放攻击；4、对有可能暴露用户信息的SQN用AK异或，达到隐藏SQN的目的；</li>
</ul>
<h3 id="3、milenage算法"><a href="#3、milenage算法" class="headerlink" title="3、milenage算法"></a>3、milenage算法</h3><p>3GPP中定义了12个安全算法f0~f9， f1 * 、 f5 * ；</p>
<ul>
<li>f0生成随机数。</li>
<li>f6和f7互逆。</li>
<li>f8：无线链路加密算法，KASUMI为基础，结合计数器模式(CTR)和输出反馈模式(OFB)</li>
<li>f9：无线链路完整性算法，以分组密码算法KASUMI为基础构造，采用了改进的CBC-MAC模式(一般称为3GPP-MAC)；</li>
<li>milenage算法是一个以分组密码为核心的一组算法框架，用于完成AKA协议中的<em>f</em>1-<em>f</em>5。</li>
</ul>
<p><img src="https://s2.loli.net/2023/09/07/hVDx5XRs7nLbpNr.png" alt="image-20230728131754652"></p>
<h4 id="（1）重新认证"><a href="#（1）重新认证" class="headerlink" title="（1）重新认证"></a>（1）重新认证</h4><p>如果用户计算的SQN（序列号）不在USIM认为的正确范围内，将发起一次重新认证。</p>
<p>AUTS：再同步认证令牌</p>
<h3 id="4、安全链接建立"><a href="#4、安全链接建立" class="headerlink" title="4、安全链接建立"></a>4、安全链接建立</h3><p>完整性模式协商和加密模式协商。<img src="https://s2.loli.net/2023/09/07/l7qbaHPcNwnWOmR.png" alt="image-20230728132900792"></p>
<h3 id="5、接入链路的加密技术和完整性保护技术"><a href="#5、接入链路的加密技术和完整性保护技术" class="headerlink" title="5、接入链路的加密技术和完整性保护技术"></a>5、接入链路的加密技术和完整性保护技术</h3><p>在用户鉴权认证以后，在移动台生成了加密密钥CK。使用户可以以秘闻的方式在无线链路上传输用户信息和信令信息。发送方采用分组密码流对原始数据加密，采用了f8算法。接收方接收到秘闻，经过相同过程，恢复出明文。<img src="https://s2.loli.net/2023/09/07/oB3mleHutaGD8Wf.png" alt="image-20230728133218402"></p>
<p>完整性保护：发送方将要传送的数据用完整性密钥IK经过f9算法产生的消息认证码MAC，附加在发出的消息后面。接收方接收到后，用同样的方法计算出HMAC，将MAC和HMAC相比较，如果二者相等，则证明了消息的完整性。</p>
<h4 id="（1）KASUMI算法"><a href="#（1）KASUMI算法" class="headerlink" title="（1）KASUMI算法"></a>（1）KASUMI算法</h4><ul>
<li>分组64bit，密钥长度128bit，主算法由线性混合函数FL和非线性混合函数FO组成；</li>
<li>非线性混合函数的非线性部分为FI，FI也是KASUMI函数惟一的非线性变化；</li>
<li>非线性盒子S7和S9是整个非线性子函数FI的核心，也是KASUMI算法的核心，它的强度就决定了密码算法的强度；</li>
</ul>
<h3 id="UMTS体系改进（与GSM比较）"><a href="#UMTS体系改进（与GSM比较）" class="headerlink" title="UMTS体系改进（与GSM比较）"></a>UMTS体系改进（与GSM比较）</h3><p><img src="https://s2.loli.net/2023/09/07/djUgvshm14qAyK3.png" alt="image-20230728134205119"></p>
<h3 id="6、2G和3G共存处理"><a href="#6、2G和3G共存处理" class="headerlink" title="6、2G和3G共存处理"></a>6、2G和3G共存处理</h3><h4 id="１、共存时的用户鉴权"><a href="#１、共存时的用户鉴权" class="headerlink" title="１、共存时的用户鉴权"></a>１、共存时的用户鉴权</h4><p>（１）用户使用USIM卡接入到网络中，通过UTRAN（UMTS陆地无线接入网）接入时，使用UMTS鉴权；当使用3G移动台和3G的MSC／VLR或SGSN的BSS接入时使用UMTS鉴权机制；当使用２G移动台和２G的MSC／VLR或SGSN的BSS接入时使用GSM鉴权机制。</p>
<p>（２）用户使用SIM卡接入网络中，鉴权过程必然是GSM系统的。</p>
<h2 id="四、网络域安全"><a href="#四、网络域安全" class="headerlink" title="四、网络域安全"></a>四、网络域安全</h2><p>主要指接入域（AN）、服务域（SN）、核心域（CN）中的网络实体之间的信令、数据的安全传输。</p>
<h3 id="１、主要机制"><a href="#１、主要机制" class="headerlink" title="１、主要机制"></a>１、主要机制</h3><p>（１）<strong>MAPsec</strong>：MAP（移动应用部分，SS７信令中专述移动通信的部分。对一个明文的MAP消息进行保护。</p>
<p>（２）<strong>IPsec</strong>：对IP层进行保护来实现对敏感信息的安全传输。能够保护更底层的消息头部。</p>
<h3 id="２、MAPsec"><a href="#２、MAPsec" class="headerlink" title="２、MAPsec"></a>２、MAPsec</h3><h4 id="（1）基本原理"><a href="#（1）基本原理" class="headerlink" title="（1）基本原理"></a>（1）基本原理</h4><p><img src="https://s2.loli.net/2023/09/07/2mM9CKVPaXsvoyU.png" alt="image-20230728175838537"></p>
<ul>
<li><p>MEA：计数器模式下的AES</p>
</li>
<li><p>MIA：CBC-MAC模式下的AES</p>
</li>
<li><p>保护模式：0、1、2（不提供保护、提供完整性保护、同时提供完整性保护和加密保护）</p>
</li>
<li><p>安全包头：</p>
<table>
<thead>
<tr>
<th>SPI</th>
<th>Original component ID</th>
<th>TVP</th>
<th>NE-ID</th>
<th>Prop</th>
</tr>
</thead>
</table>
<p>SPI ：安全参数索引，它与目标PLMN ID一起指向一个唯一的MAPsec安全关联(SA)。</p>
<p>Original component ID：原始MAP消息的类型，以便接收方能够正确处理MAP消息。</p>
<p>TVP：时变参数，32比特的时间戳，用来抵御重放攻击。</p>
<p>NE-ID：网元标识，用于同一时间戳内不同的网元产生不同IV</p>
<p>Prop：所有权域，用于同一时间戳内同一网元在加密不同的Map消息时可以产生不同的IV。</p>
</li>
</ul>
<h4 id="（2）密钥管理中心KAC"><a href="#（2）密钥管理中心KAC" class="headerlink" title="（2）密钥管理中心KAC"></a>（2）密钥管理中心KAC</h4><p>一个网络只有一个KAC，</p>
<ul>
<li>保存自己的公钥对</li>
<li>保存其他网络KAC的公钥对</li>
<li>保存向其他网络发送敏感数据的对称对话密钥</li>
<li>保存用于解密其他网络发送来的敏感数据的对称对话密钥</li>
<li>安全分发对称会话密钥到本网的成员实体。</li>
</ul>
<h4 id="（3）MAPsec机制的安全模型"><a href="#（3）MAPsec机制的安全模型" class="headerlink" title="（3）MAPsec机制的安全模型"></a>（3）MAPsec机制的安全模型</h4><p><img src="https://s2.loli.net/2023/09/07/UIzqGOVP2vXhZrd.png" alt="image-20230728180829523"></p>
<ol>
<li>同一个通信网络的网络成员间传送数据只使用第二、第三层，不用第一层。</li>
<li>同一运营商的网络都要执行第二层功能。</li>
<li>密钥交换采用上述密钥交换方式</li>
<li>第一层KAC把协商好的用于发送和解会搜数据的会话密钥分发给相关网络成员。</li>
<li>第三层使用对称加密算法，采用分发好的密钥安全的交换敏感数据。</li>
<li>Eksxy(数据)表示了网络X使用对称密钥算法加密数据发送给网络Y。</li>
</ol>
<h3 id="3、IPSec"><a href="#3、IPSec" class="headerlink" title="3、IPSec"></a>3、IPSec</h3><p>IP层上的通信进行保护<img src="https://s2.loli.net/2023/09/07/iSrCG86k2Bv5PQx.png" alt="image-20230728182214577"></p>
<p>工作方式：认证头（AH）、封装安全负载（ESP）</p>
<h4 id="IPSec协议组成"><a href="#IPSec协议组成" class="headerlink" title="IPSec协议组成"></a>IPSec协议组成</h4><p>1、<strong>AH：Authentication Header</strong>。为IP通信提供数据源认证、数据完整性和反重播保证，他能保护通信免受篡改，但不能防止窃听，适合用于传输非机密数据。</p>
<p>传输模式（不需要创建新的IP包头）和隧道模式（为每一个包创建一个新的IP包头）</p>
<p><img src="https://s2.loli.net/2023/09/07/VC4TMpfE8DGBW7R.png" alt="image-20230728182534322"></p>
<p><img src="https://s2.loli.net/2023/09/07/VsoRZXjm4AiPakT.png" alt="image-20230728182545584"></p>
<p>2、<strong>ESP：Encapsulating Security Payload</strong>。为IP数据包提供完整性检查、认证和加密，比AH更完善。</p>
<p>除AH功能外，还提供对IP报文的加密功能。<strong>隧道模式和传输模式</strong></p>
<p>3、<strong>IKE：Internet Key Exchange</strong>。密钥协商和密钥管理。</p>
<h2 id="五、GSM-amp-UMTS安全机制的对比"><a href="#五、GSM-amp-UMTS安全机制的对比" class="headerlink" title="五、GSM&amp;UMTS安全机制的对比"></a>五、GSM&amp;UMTS安全机制的对比</h2><p><img src="https://s2.loli.net/2023/09/07/E9a8LMj2eP3D5cl.png" alt="image-20230728182710331"></p>
<h1 id="4G移动通信系统安全（LTE）"><a href="#4G移动通信系统安全（LTE）" class="headerlink" title="4G移动通信系统安全（LTE）"></a>4G移动通信系统安全（LTE）</h1><p><strong>4G: LTE+SAE+IMS</strong></p>
<p>LTE：是无线接入网，支持1.25MHz~20MHz宽带。</p>
<p>SAE：是面向全IP分组域核心网的演进，又称为演进的分组核心网EPC。</p>
<p>IMS：主要解决将语音等多媒体业务承载到4G网络，使得分组域（PS）具有电路域（CS）的部分功能，支持回话类和非回话类的多媒体业务。</p>
<h2 id="一、LTE的网络架构"><a href="#一、LTE的网络架构" class="headerlink" title="一、LTE的网络架构"></a>一、LTE的网络架构<img src="https://s2.loli.net/2023/09/07/xBCApVNE2siq1Dy.png" alt="image-20230728184032279"></h2><ul>
<li><strong>MME移动性管理实体</strong>：SAE的控制核心，主要负责用户接入控制、业务承载控制、寻呼、切换控制等控制信令处理。</li>
<li><strong>S-GW服务网关</strong>：本站基站间切换时的锚定点，负责在基站和P-GW之间传输数据信息、为下行数据包提供缓存、基于用户的计费</li>
<li><strong>HSS</strong>：用于存储用户签约信息的数据库，存储的信息包括用户标识、用户安全控制、用户位置、用户策略控制等信息。</li>
<li><strong>P-GW分组数据网网关</strong>：分组数据网关作为数据承载的锚定点，提供以下功能：包转发、包解析、合法监听、基于业务的计费、业务的QoS控制，以及负责和非3GPP网络间的互联等。</li>
<li><strong>eNodeB演进基站</strong></li>
</ul>
<p>注：在3G中节点间通过RNC（无线网络控制器）连接，无法直接通信。但在4G中，结点间可以直接通信。<img src="https://s2.loli.net/2023/09/07/aFvqfwE3NzWoKGy.png" alt="image-20230728185836438"></p>
<p><img src="https://s2.loli.net/2023/09/07/wpd7BQ5uGnUFz9g.png" alt="image-20230728185913525"></p>
<h2 id="二、LTE的安全框架"><a href="#二、LTE的安全框架" class="headerlink" title="二、LTE的安全框架"></a>二、LTE的安全框架</h2><p><img src="https://s2.loli.net/2023/09/07/nR3BTILkxCVoOAp.png" alt="image-20230729145243509"></p>
<h3 id="1、安全威胁"><a href="#1、安全威胁" class="headerlink" title="1、安全威胁"></a>1、安全威胁</h3><ul>
<li>eNodeB体积相对较小，成本低，可能部署在不安全的地点。因此与核心网络连接所使用的传输链路也是不安全的。</li>
<li>对eNodeB可能存在物理攻击和网络攻击。</li>
</ul>
<h3 id="2、安全架构"><a href="#2、安全架构" class="headerlink" title="2、安全架构"></a>2、安全架构</h3><p><img src="https://s2.loli.net/2023/09/07/XYUMg1bOjm5JneN.png" alt="image-20230729145707503"></p>
<ul>
<li>接入网络安全（I）：为用户提供对系统服务的安全接入，保护了无线链路免受攻击。包括USIM卡、移动设备ME、无线接入网AN、服务网SN、归属环境HE之间的安全通信。重点时SN和HE之间的安全通信。</li>
<li>网络域安全（II）：使AN和SN、SN和HE之间可以的交互信令及用户数据，抵御有线网络连接范围内的各种攻击。</li>
<li>用户域安全（III）：保证对移动台的安全访问，实现用户终端对USIM卡的识别和安全交互。</li>
<li>应用域安全（IV）：实现用户应用与运营商应用之间可安全的交互（应用层）。</li>
<li>安全的可视性和可配置性（V）：用来通知用户一个安全特性是否处于使用状态，以及一些服务是否需要以来某些安全特性。</li>
</ul>
<p>注：</p>
<p>1、在ME和SN之间增加了双向箭头表明移动设备和服务网之间也存在非接入层安全。</p>
<p>2、AN和SN之间增加双向箭头表明接入网和服务网之间的通信需要进行安全保护。</p>
<p>３、增加了服务网认证的概念，因此归属环境（HE）和服务网之间的箭头由单向箭头改为双向箭头。</p>
<h3 id="３、LTE安全要求"><a href="#３、LTE安全要求" class="headerlink" title="３、LTE安全要求"></a>３、LTE安全要求</h3><ol>
<li>继续使用USIM。</li>
<li>移动终端(UE)与网络之间要有双向认证。</li>
<li>无线链路的机密性可选</li>
<li>无线资源控制层RRC和非接入层NAS要有强制完整性保护机制。</li>
<li>用户层面的数据完整性保护可选。</li>
</ol>
<h3 id="4、接入层和非接入层"><a href="#4、接入层和非接入层" class="headerlink" title="4、接入层和非接入层"></a>4、接入层和非接入层</h3><p>eNB处于一个完全不信任区域，因此LTE的安全包括两个层次。</p>
<ul>
<li>接入层安全(AS)：移动终端UE和eNB之间的安全，主要执行AS信令的加密和完整性保护。</li>
<li>非接入层安全（NAS）：UE和移动性管理实体MME之间的安全，主要执行NAS信令的加密和完整性保护。</li>
</ul>
<h2 id="三、安全机制"><a href="#三、安全机制" class="headerlink" title="三、安全机制"></a>三、安全机制</h2><h3 id="1、匿名"><a href="#1、匿名" class="headerlink" title="1、匿名"></a>1、匿名</h3><p>定义了一个明确的UE临时标识GUTI，以隐藏IMSI。S-TMSI是GUTI的缩简形式，用在接入网络之后的身份标识，每次接入时都会变化。</p>
<p>MME在用户接入后，根据约定好的生成算法和产生的随机数生成S-TMSI。</p>
<p>MME在分配完S-TMSI后，保存其与IMSI之间的映射关系。在接入流程完成后，用户使用S-TMSI与MME进行交互通信。</p>
<h3 id="2、认证"><a href="#2、认证" class="headerlink" title="2、认证"></a>2、认证</h3><p>3GPP组织定义了EPS-AKA方案。</p>
<ul>
<li>HSS通过对MME发送的服务网络号SNID来验证服务网的合法性，提高来安全性。</li>
<li>采用层次化的密钥生成机制，提高了通信的保密性，在身份认证完成后，首先协商生成的是基础密钥K_ASME，再根据不同的通信数据类型和通信链路，用不同的算法计算出不同的完整性保护密钥IK和加密密钥CK。</li>
<li>加入了独立的SQN机制，对认证向量采用按序处理，减少了以前3G-AKA中由于SQN不同步而带来的系统开销。</li>
</ul>
<h3 id="3、密钥管理"><a href="#3、密钥管理" class="headerlink" title="3、密钥管理"></a>3、密钥管理</h3><p><img src="https://s2.loli.net/2023/09/07/nj1WRUkc6Q5lwmh.png" alt="image-20230729160527964"></p>
<h1 id="5G移动通信系统安全"><a href="#5G移动通信系统安全" class="headerlink" title="5G移动通信系统安全"></a>5G移动通信系统安全</h1><h2 id="一、系统架构"><a href="#一、系统架构" class="headerlink" title="一、系统架构"></a>一、系统架构</h2><p><img src="https://s2.loli.net/2023/09/07/5Qt7YKZaNDvRqkI.png" alt="image-20230729160843933"></p>
<p><img src="https://s2.loli.net/2023/09/07/p8IknR6wsQyZDeE.png" alt="image-20230729160903699"></p>
<h1 id="WLAN安全"><a href="#WLAN安全" class="headerlink" title="WLAN安全"></a>WLAN安全</h1><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p>WLAN：把远程计算机用无线方式连入一个计算机网络中，作为网络的一个节点，使之能够获取网络上的所有服务。以无线方式入网的计算机具有一定程度的移动性，在一定的区域内移动但又随时和网络保持联系。</p>
<p>由无线网卡、无线接入点AP，计算机和有关设备组成。</p>
<p>按采取的类型分类：网桥连接型、访问节点连接型、Hub接入型和无中心型。</p>
<p>采用802.11系列标准。安全机制：扩展服务集标识符（ESSID）、开放系统认证、共享密钥认证、访问控制列表、密钥管理</p>
<h2 id="二、WEP"><a href="#二、WEP" class="headerlink" title="二、WEP"></a>二、WEP</h2><p>有线对等保密，是802.11协议中保障数据传输安全的核心部分。</p>
<h3 id="1、鉴权"><a href="#1、鉴权" class="headerlink" title="1、鉴权"></a>1、鉴权</h3><p>四步握手，单项认证</p>
<p><strong>共享密钥验证：</strong></p>
<ol>
<li>客户发出验证请求</li>
<li>无线接入点AP产生一个挑战信息，并发送给客户端。</li>
<li>客户端使用WEP密钥加密数据包并且将她发回</li>
<li>AP解密数据包并且同原消息比较。</li>
<li>AP向客户端发出成功信息。<img src="https://s2.loli.net/2023/09/07/nDOvFflUJgotywE.png" alt="image-20230729163421330"></li>
</ol>
<h3 id="2、私密性"><a href="#2、私密性" class="headerlink" title="2、私密性"></a>2、私密性</h3><p>RC4流密码加密，密钥长度40bit/104bit。</p>
<p><img src="https://s2.loli.net/2023/09/07/avUTgqucsAjPHYI.png" alt="image-20230729163811135"></p>
<p><img src="https://s2.loli.net/2023/09/07/ONSFiCkEqv2ZpRo.png" alt="image-20230729163822196"></p>
<p>注：</p>
<p>1、WEP存在弱密钥，当获得足够多的弱密钥时，可恢复出WEP的共享密钥。</p>
<p>2、生成RC4 密码流的初始化向量IV是明文发送，可能会发生IV重复使用，使用相同的加密序列加密两次会导致信息泄露。</p>
<p>3、RC4 是一个序列密码加密算法，发送者用一个密钥序列和明文异或产生密文，接收者用相同的密钥序列与密文异或恢复出明文。一旦密钥序列被重用，攻击者很容易能够恢复出明文。</p>
<p>4、上述安全漏洞和WEP对加密算法的使用机制有关，即使增加密钥长度也不可能增加安全性。</p>
<p>5、缺乏完整性保护。设计了综合检验值ICV进行完整性保护，来防止传输错误，使用了CRC32算法实现，但CRC32是线性运算，是设计用来检测消息中的随机错误，不是安全杂凑函数，不具备密码学上的安全性，攻击者可以篡改加密的信息。</p>
<p>完整性：CRC32，</p>
<h2 id="三、WPA"><a href="#三、WPA" class="headerlink" title="三、WPA"></a>三、WPA</h2><p><strong>预置共享密钥（WPA-PSK）</strong>：适用于家庭用户或中小企业。无须专门的认证服务器，要求在每个WLAN节点上预先输入一个密钥即可实现，只要密钥吻合，用户就可以获得WLAN的访问权。</p>
<p><strong>802.1x+EAP</strong>：适合大型企业网络，用户必须提交认证凭证，通过特定的认证服务器来实现认证，在获得授权后才能通过端口使用网络资源。</p>
]]></content>
  </entry>
  <entry>
    <title>《深入理解LTE-A》学习笔记（二）</title>
    <url>/2023/09/07/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3LTE-A%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<h1 id="《深入理解LTE-A》学习笔记（二）"><a href="#《深入理解LTE-A》学习笔记（二）" class="headerlink" title="《深入理解LTE-A》学习笔记（二）"></a>《深入理解LTE-A》学习笔记（二）</h1><span id="more"></span>

<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><table>
<thead>
<tr>
<th>名词</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>OFDM</td>
<td>正交频分复用，将信道分为若干子信道，将高速数据信号转换成并行的低速子数据流，调制在每个子信道上进行传输。</td>
</tr>
<tr>
<td>SC-FDMA</td>
<td>单载波频分复用接入技术。实现动态频带分配，通过DFT-S-OFDM技术实现，带宽大小取决于用户的需求和系统调度的结果。</td>
</tr>
<tr>
<td>FDD</td>
<td>上下行数据在不同的频率内传输，使用成对频谱，支持全双工和半双工。</td>
</tr>
<tr>
<td>slot</td>
<td>时隙，每个子帧由slot数量取决于子载波的间隔。</td>
</tr>
<tr>
<td>DwPTS</td>
<td>下行导频时隙</td>
</tr>
<tr>
<td>GP</td>
<td>主保护时隙</td>
</tr>
<tr>
<td>UpPTS</td>
<td>行导频时隙</td>
</tr>
<tr>
<td>ISI</td>
<td>符号间干扰，由无线电波传输多径与衰落以及抽样失真引起的</td>
</tr>
<tr>
<td>ICI</td>
<td>载波间干扰，子载波的正交性被破坏，影响接收侧的解调</td>
</tr>
<tr>
<td>PDSCH</td>
<td>物理下行链路共享通道</td>
</tr>
<tr>
<td>SRS</td>
<td>探测（侦听）参考信号</td>
</tr>
<tr>
<td>PRACH</td>
<td>物理随机接入信道</td>
</tr>
<tr>
<td>RE</td>
<td>LTE中，频率上一个子载波及时域上一个symbol，称为一个RE。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="第二章-LTE时域、频域和空间域资源"><a href="#第二章-LTE时域、频域和空间域资源" class="headerlink" title="第二章  LTE时域、频域和空间域资源"></a>第二章  LTE时域、频域和空间域资源</h1><p>本章分别从时域、频域、空间域来说明LTE中的空口资源。LTE在下行使用OFDM，上行使用SC-FDMA。</p>
<h2 id="一、时域"><a href="#一、时域" class="headerlink" title="一、时域"></a>一、时域</h2><h3 id="1、基本时间单位"><a href="#1、基本时间单位" class="headerlink" title="1、基本时间单位"></a>1、基本时间单位</h3><p>Ts=1/(15000* 2048) =1/ 30720000 秒。</p>
<p>基于FFT(快速傅里叶变换)且FFT大小等于2048的发射机/接收机所使用的采样时间。</p>
<h3 id="2、系统帧结构分类"><a href="#2、系统帧结构分类" class="headerlink" title="2、系统帧结构分类"></a>2、系统帧结构分类</h3><p>上下行传输都被组织成10ms（T<del>f</del>=307200*T<del>s</del>=10ms）的系统帧（无线帧）。LTE支持两种系统帧结构：用于FDD的类型1和用于TDD的类型2。</p>
<ul>
<li><p><strong>用于FDD的类型1</strong></p>
<p>FDD：上下行数据在不同的频率内传输，使用成对频谱，支持全双工和半双工。</p>
<p>每个系统帧长10ms，由10个子帧组成。每个子帧1ms，由两个连续的slot时隙组成，每个slot长达0.5ms（T<del>slot</del>=155360*T<del>s</del>=0.5ms）</p>
<p>在FDD中，上下行传输通过频域区分，在每个10ms内，各有10个子帧可用于上行传输和下行传输。</p>
<p><img src="https://s2.loli.net/2023/09/07/3t4FD8agBbPpsKv.png" alt="image-20230907164712669"></p>
</li>
<li><p><strong>用于TDD的类型2</strong></p>
<p>TDD：上下行数据在同一频道内传输，使用非成对频道。</p>
<p>每个系统帧长10ms，由2个长5ms的半帧组成。每个半帧由5个1ms的子帧组成。其中包括正常子帧和特殊子帧。每个子帧由2个连续的slot时隙组成，每个slot长达0.5ms。</p>
<p>在TDD中，上下行传输通过时域区分。子帧0、5以及DwPTS总是用于下行传输，UpPTS以及紧随特殊子帧之后的子帧总是用于上行传输。</p>
<p><img src="https://s2.loli.net/2023/09/07/4csE2OyGxwiILvT.png" alt="image-20230907165730600"></p>
</li>
</ul>
<p>注：TDD支持7种上下行配置，对应不同的上下行配比，“D”对应下行子帧，“U”对应上行子帧，“S”对应特殊子帧。</p>
<p>同时TDD上下行配置支持5ms和10ms的下行到上行的切换周期。在5ms的切换周期中，在2个半帧中都存在特殊子帧。在10ms的切换周期中，只有第一个半帧存在特殊子帧。</p>
<p><img src="https://s2.loli.net/2023/09/07/YP8wIAvtcdzRQ4L.png" alt="image-20230907175500956"></p>
<h3 id="3、特殊子帧"><a href="#3、特殊子帧" class="headerlink" title="3、特殊子帧"></a>3、特殊子帧</h3><p>TDD中的正常子帧和FDD中的子帧结构相同。</p>
<p>TDD中的特殊子帧包含3个域：DwPTS、GP和UpPTS，三个域相加等于1ms。特殊子帧有9种不同的配置，对应不同的DwPTS和UpPTS长度。</p>
<p>特殊子帧的配置是通过RRC消息种的 <em>TDD-Config</em> -&gt; <em>specialSubframePatterns</em>字段来设置的。</p>
<h3 id="4、系统帧"><a href="#4、系统帧" class="headerlink" title="4、系统帧"></a>4、系统帧</h3><p>系统帧的编号范围0<del>1023 ，一个系统帧的子帧编号范围0</del>9。 协议种系统帧号使用n<del>f</del>表示，一个系统帧内slot号用n<del>s</del>表示。</p>
<p>1、符号symbol</p>
<p>一个slot由多个符号组成，每个符号（用<em><strong>l</strong></em> 表示）由循环前缀CP和可用符号时间组成。上行使用SC-FDMA符号，下行使用OFDM符号。一个slot包含的符号数取决于循环前缀的长度和子载波的间距。</p>
<p>下行：<img src="https://s2.loli.net/2023/09/07/dkzqD35r7ogeNfx.png" alt="image-20230907182741811"></p>
<p>上行：<img src="https://s2.loli.net/2023/09/07/8hipe79nFx5TZzr.png" alt="image-20230907182815298"></p>
<p>注：每个slot由7个符号（0-6组成）。当正常子帧使用扩展的循环前缀时，每个slot由6个符号（0-5组成）。</p>
<p>2、循环前缀</p>
<p>OFDM系统中会插入一段空白符号作为保护间隔，这样虽然能消除ISI（符号间干扰）但不能消除ICI（子载波间干扰）。循环前缀是将OFDM信号的最后一定长度内的部分提取出来放在OFDM信号的头部，将加入了循环前缀后变长了的OFDM信号作为新的OFDM信号，这样就可以完全消除ISI和ICI。</p>
<p>循环前缀也存在正常的循环前缀和扩展的循环前缀之分，其区别在于长度的不同。UE在小区搜索过程中确定下行的循环前缀的长度，并接受RRC消息中UL-CyclicPrefixLength 字段确定上行的循环前缀长度。</p>
<p>下行：<img src="https://s2.loli.net/2023/09/07/R2MXr8A46k7PJh5.png" alt="image-20230907192548387"></p>
<p>上行：<img src="https://s2.loli.net/2023/09/07/xpkDVZv56YPMNEB.png" alt="image-20230907192600569"></p>
<p>对于正常的循环前缀，每个slot的第一个符号的循环前缀长度比其它的符号要大。（因为0.5ms的slot不能被7整除，所有第一个符号的循环前缀要长一些。对于扩展的循环前缀则不存在这个问题）。</p>
<p>一个slot长度为所有符号的长度相加。</p>
<p>对于正常的循环前缀0.5ms=15360* T<del>s</del>=((160+2048)+(114+2048) *6) *T<del>s</del></p>
<p>对于扩展的循环前缀0.5ms=15360* T<del>s</del>=((512+2048)*6) * T<del>s</del></p>
<p>对于TDD下的特殊子帧，DwPTS、GP、UpPTS三个时长相加等于1ms=30720*T<del>s</del></p>
<p><strong>DwPTS</strong>可被当做正常的下行子帧来看待，既可用于PDSCH传输。但由于DwPTS小于正常的下行子帧，所以其携带的数据量要更少。（通常为下行子帧的0.5倍）。</p>
<p><strong>UpPTS</strong> 由于长度太短，不能用于 PUSCH 传输，而只能用于 SRS 或 PRACH 传输。</p>
<p>注：1、循环前缀更长，虽然从开销的角度来说效率更低，但适合带有广泛的传输延迟的特定场景。但不是所有情况都能给大型小区带来好处，比如链路的性能受限于噪声，而不是受限于循环前缀不能覆盖剩余的时间弥散所导致的信号损坏，此时使用更长的循环前缀所带来的额外的无线信道时间弥散的可靠性，无法证明使用更长的循环前缀所需要的额外能量开销是合理的。</p>
<p>2、同一个系统帧的不同子可能使用不同的循环前缀长度。</p>
<h2 id="二、频域"><a href="#二、频域" class="headerlink" title="二、频域"></a>二、频域</h2><h3 id="1、基本单位"><a href="#1、基本单位" class="headerlink" title="1、基本单位"></a>1、基本单位</h3><p>一个子载波，上下行的子载波的间距均为15kHz。每个间隔对应每个符号内可用的符号时间为2048*T<del>s</del></p>
<h3 id="2、系统带宽"><a href="#2、系统带宽" class="headerlink" title="2、系统带宽"></a>2、系统带宽</h3><p>频域上可用的所有资源称之为系统带宽，RB是单位，每个RB包含12个子载波。</p>
<p>下行系统带宽使用N^DL^<del>RB</del>，eNode通过MIB告知UE使用的下行系统带宽。</p>
<p>上行系统带宽使用N^UL^<del>RB</del>，eNode通过SIB2告知UE使用的上行系统带宽。</p>
<p>注：对于TDD而言，上下行的系统带宽是相同的。</p>
<p>下行时频资源网络：<img src="https://s2.loli.net/2023/09/07/PQwfisRKqJ6nbTG.png" alt="image-20230907205009505"></p>
<p>注：</p>
<p>N^*^<del>RB</del>表示系统带宽，对于下行，为N^DL^<del>RB</del>，对于上行，为N^UL^<del>RB</del></p>
<p>N^*^<del>symb</del>表示每个slot包含的符号数，对于下行，为N^DL^<del>symb</del>，对于上行，为N^UL^<del>symb</del></p>
<p>N^RB^<del>sc</del>表示每个RB包含的子载波数。</p>
<p>网格中的每一个元素称为一个RE，用（k,l）来索引。</p>
<p><strong>RE</strong>是LTE中最小的物理资源。<strong>一个RE可存放一个调制符号</strong>（symbol，强调数据，与时域中的符号不是一个概念），该调制符号可使用QPSK（一个RE存放2比特数据）、16QAM（一个RE存放4比特数据）或64QAM调制（一个RE存放6比特数据）。</p>
<p>一个RB在时域上包含6或7个连续的符号，在频域上包含12个连续的子载波，因此对于一个正常的循环前缀，一个RB包含84个RE，对于扩展的循环前缀，每个RB包含6*12=72个RE。（这里的RB既包含时域上的信息（1个slot），又包含频域上的信息（12个子载波），和前面系统带宽中的RB不同）。</p>
<p>注：RB的基本单位是一个slot（0.5ms），LTE中调度的基本时间单位是一个子帧，称为一个TTI。一个TTI内的调度的最小单位实际上由同一个子帧上时间相连的2个RB组成，称为RB pair。对于一个RB，最小分配2个RB。</p>
<h3 id="3、DC子载波"><a href="#3、DC子载波" class="headerlink" title="3、DC子载波"></a>3、DC子载波</h3><p>对于下行而言，在载波中心频点的位置有一个未使用的DC子载波。DC子载波未被下行传输使用的原因在于该子载波可能由本地晶振泄露等原因而遭受不成比例的高干扰。</p>
<p>对于上行来说，载波中心频率上并不存在DC子载波。因为中心频点处的未使用DC子载波会导致无法将整个上行系统带宽分配给一个单一UE的同时，将其映射到OFDM调制器的连续输入上，而对于保持上行数据传输的DFTS-OFDM调制的低立方度量特性是必须的。</p>
<h2 id="三、空间域"><a href="#三、空间域" class="headerlink" title="三、空间域"></a>三、空间域</h2><p>在空间维度中，以“层”来度量，并使用多天线传输和多天线接收技术来实现。每一层对应一条有效的数据流，并会映射到逻辑上的“天线端口”上。每个天线端口对应一个时频资源网格，并有一个对应的参考信息，以便接收端进行信道估计和相干解调。</p>
<p>采用空分复用，在相同的时频资源上，可同时存在多层，同时传输多条数据流，这样频谱的利用率更高，吞吐量也越高。</p>
]]></content>
  </entry>
</search>
